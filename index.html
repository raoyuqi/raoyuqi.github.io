<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"raoyuqi.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="奇遇的博客">
<meta property="og:url" content="https://raoyuqi.github.io/index.html">
<meta property="og:site_name" content="奇遇的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://raoyuqi.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>奇遇的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="奇遇的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">奇遇的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/09/23/unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Mesh%E5%90%88%E5%B9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/23/unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Mesh%E5%90%88%E5%B9%B6/" class="post-title-link" itemprop="url">Mesh合并</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-23 11:40:42" itemprop="dateCreated datePublished" datetime="2023-09-23T11:40:42+08:00">2023-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-24 15:05:33" itemprop="dateModified" datetime="2023-09-24T15:05:33+08:00">2023-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Uniy/" itemprop="url" rel="index"><span itemprop="name">Uniy</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Uniy/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>要在屏幕上绘制游戏对象，引擎必须向图形 API（例如 OpenGL 或 Direct3D）发出绘制调用。绘制调用通常为资源密集型操作，图形 API 为每次绘制调用执行大量工作，从而导致 CPU 端的性能开销。此开销的主要原因是绘制调用之间的状态变化（例如切换到不同材质），而这种情况会导致图形驱动程序中执行资源密集型验证和转换步骤。</p>
<p>Unity可以通过以下方法进行优化：</p>
<ul>
<li><strong>动态批处理</strong>：对于足够小的网格，此方法会在 CPU 上转换网格的顶点，将许多相似顶点组合在一起，并一次性绘制它们。</li>
<li><strong>静态批处理</strong>：将静态（不移动）游戏对象组合成大网格，并以较快的速度渲染它们。</li>
</ul>
<p>但是，也有一些缺点；静态批处理会导致内存和存储开销，动态批处理会产生一些 CPU 开销。</p>
<p>除此之外还可以利用Unity提供的 <strong>Mesh.CombineMeshes</strong> API在运行是合并网格，最近在优化具有换装需求的项目时正好使用到。</p>
<p><br></p>
<h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="2-1-流程"><a href="#2-1-流程" class="headerlink" title="2.1 流程"></a>2.1 流程</h2><p><strong>前提：使用相同材质</strong></p>
<ul>
<li>收集需要合并的Texture</li>
<li>收集需要合并的UV信息</li>
<li>合并根节点下的Mesh、Texture、UV</li>
</ul>
<h2 id="2-2-收集需要合并Texture"><a href="#2-2-收集需要合并Texture" class="headerlink" title="2.2 收集需要合并Texture"></a>2.2 收集需要合并Texture</h2><p>每个部位用到的Texture不同，因此先合并贴图：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 收集组件的贴图</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;model&quot;&gt;</span>模型根节点<span class="doctag">&lt;/param&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Texture2D&gt; <span class="title">CollectCombineTextures</span>(<span class="params">GameObject model</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模型中所有的SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">var</span> skinnedMeshRenderers = model.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();</span><br><span class="line">    <span class="comment">// 需要合并的贴图</span></span><br><span class="line">    <span class="keyword">var</span> textureList = <span class="keyword">new</span> List&lt;Texture2D&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; skinnedMeshRenderers.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> skinMeshRenderer = skinnedMeshRenderers[i];</span><br><span class="line">        <span class="keyword">var</span> mat = skinMeshRenderer.sharedMaterial;</span><br><span class="line">        <span class="keyword">if</span> (mat == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// var texture2d = mat.GetTexture(&quot;_BaseMap&quot;) as Texture2D;</span></span><br><span class="line">        <span class="keyword">var</span> texture2d = mat.mainTexture <span class="keyword">as</span> Texture2D;</span><br><span class="line">        textureList.Add(texture2d);</span><br><span class="line">        <span class="keyword">return</span> textureList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-收集UV数据"><a href="#2-3-收集UV数据" class="headerlink" title="2.3 收集UV数据"></a>2.3 收集UV数据</h2><p>在本次实践中，shader用到了uv2，因此需要一起合并，类似可以拓展到uv3，uv4…</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Vector2[]&gt; CollectCombineUVList(GameObject model, List&lt;Vector2[]&gt; uv1List, <span class="keyword">ref</span> <span class="built_in">int</span> uv1Count, List&lt;Vector2[]&gt; uv2List, <span class="keyword">ref</span> <span class="built_in">int</span> uv2Count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模型中所有的SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">var</span> skinnedMeshRenderers = model.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; skinnedMeshRenderers.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> skinMeshRenderer = skinnedMeshRenderers[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储mesh的uv</span></span><br><span class="line">        uv1List.Add(skinMeshRenderer.sharedMesh.uv);</span><br><span class="line">        uv1Count += skinMeshRenderer.sharedMesh.uv.Length;</span><br><span class="line"></span><br><span class="line">        uv2List.Add(skinMeshRenderer.sharedMesh.uv);</span><br><span class="line">        uv2Count += skinMeshRenderer.sharedMesh.uv.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-合并完整代码"><a href="#2-4-合并完整代码" class="headerlink" title="2.4 合并完整代码"></a>2.4 合并完整代码</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SkinnedMeshCombine</span>(<span class="params">GameObject model</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模型中所有的SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">var</span> skinnedMeshRenderers = model.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();</span><br><span class="line">    <span class="keyword">var</span> combineList = <span class="keyword">new</span> List&lt;CombineInstance&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨骼数据</span></span><br><span class="line">    <span class="keyword">var</span> bones = <span class="keyword">new</span> List&lt;Transform&gt;();</span><br><span class="line">    <span class="comment">// uv</span></span><br><span class="line">    <span class="keyword">var</span> uvCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> uvList = <span class="keyword">new</span> List&lt;Vector2[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uv2的起始位置</span></span><br><span class="line">    <span class="keyword">var</span> uv2StartIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 需要合并的贴图</span></span><br><span class="line">    <span class="keyword">var</span> textureList = <span class="keyword">new</span> List&lt;Texture2D&gt;();</span><br><span class="line"></span><br><span class="line">    Material material = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 骨骼</span></span><br><span class="line">    <span class="keyword">var</span> allBones = model.GetComponentsInChildren&lt;Transform&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历SkinnedMeshRenderer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; skinnedMeshRenderers.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> skinMeshRenderer = skinnedMeshRenderers[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回分配给渲染器的第一个材质</span></span><br><span class="line">            material = skinMeshRenderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要合并的网格</span></span><br><span class="line">        <span class="keyword">var</span> combine = <span class="keyword">new</span> CombineInstance();</span><br><span class="line">        combine.mesh = skinMeshRenderer.sharedMesh;</span><br><span class="line">        combine.transform = skinMeshRenderer.transform.localToWorldMatrix;</span><br><span class="line"></span><br><span class="line">        combineList.Add(combine);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贴图</span></span><br><span class="line">        <span class="keyword">var</span> texture2d = mat.mainTexture <span class="keyword">as</span> Texture2D;</span><br><span class="line">        textureList.Add(texture2d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集需要合并的骨骼信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; skinMeshRenderer.bones.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; allBones.Length; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(smr.bones[j].name == allBones[k].name)</span><br><span class="line">                &#123;</span><br><span class="line">                    bones.Add(allBones[k]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储mesh的uv</span></span><br><span class="line">        uvList.Add(skinMeshRenderer.sharedMesh.uv);</span><br><span class="line">        uvCount += skinMeshRenderer.sharedMesh.uv.Length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skinMeshRenderer.name == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 针对某个mesh使用了uv2</span></span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">            uv2List.Add(render.sharedMesh.uv2);</span><br><span class="line">            uv2Count += render.sharedMesh.uv2.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">            uv2StartIndex = uvCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁子物体</span></span><br><span class="line">        Object.Destroy(skinMeshRenderer.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始合并，创建一个新的节点</span></span><br><span class="line">    <span class="keyword">var</span> combineObj = <span class="keyword">new</span> GameObject(<span class="string">&quot;Combine&quot;</span>);</span><br><span class="line">    combineObj.transform.parent = model.transform;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贴图合并</span></span><br><span class="line">    <span class="keyword">var</span> skinnedMeshAtlas = <span class="keyword">new</span> Texture2D(<span class="number">1024</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">var</span> packingResults = skinnedMeshAtlas.PackTextures(textureList.ToArray(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置uv</span></span><br><span class="line">    <span class="keyword">var</span> atlasUVs = <span class="keyword">new</span> Vector2[uvCount]; <span class="comment">// 大Mesh的UV列表</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; uvList.Count; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Vector2 uv <span class="keyword">in</span> uvList[index])</span><br><span class="line">        &#123;</span><br><span class="line">            atlasUVs[counter].x = Mathf.Lerp(packingResults[index].xMin, packingResults[index].xMax, uv.x);</span><br><span class="line">            atlasUVs[counter].y = Mathf.Lerp(packingResults[index].yMin, packingResults[index].yMax, uv.y);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uv2采样</span></span><br><span class="line">    <span class="keyword">var</span> meshAtlas2 = <span class="keyword">new</span> Texture2D(<span class="number">512</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">var</span> packingResults2 = meshAtlas2.PackTextures(<span class="keyword">new</span> Texture2D[] &#123; numberData.m_NumTexture &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> atlasUV2s = <span class="keyword">new</span> Vector2[uvCount]; <span class="comment">// 大Mesh的UV2列表</span></span><br><span class="line">    counter = uv2StartIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; uv2List.Count; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Vector2 uv <span class="keyword">in</span> uv2List[index])</span><br><span class="line">        &#123;</span><br><span class="line">            atlasUV2s[counter].x = Mathf.Lerp(packingResults2[index].xMin, packingResults2[index].xMax, uv.x);</span><br><span class="line">            atlasUV2s[counter].y = Mathf.Lerp(packingResults2[index].yMin, packingResults2[index].yMax, uv.y);</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> smr = combineObj.AddComponent&lt;SkinnedMeshRenderer&gt;();</span><br><span class="line">    smr.sharedMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    smr.sharedMesh.CombineMeshes(combineList.ToArray(), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    smr.sharedMesh.uv = atlasUVs;</span><br><span class="line">    smr.sharedMesh.uv2 = atlasUV2s;</span><br><span class="line">    smr.material = material;</span><br><span class="line">    smr.material.mainTexture = skinnedMeshAtlas;</span><br><span class="line">    smr.bones = bones.ToArray();</span><br><span class="line">    <span class="comment">// smr.rootBone = transform;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本模型下有多个SkinnedMeshRenderer，合并后只有一个了（旧的都被删除），虽然占用的内存变多了，但是原本渲染一个模型需要渲染头、四肢、身体、鞋子，和额外的装备，每部分都是不同的mesh，这样至少需要4个Draw Call（没有额外装备的情况），合并mesh和texture后，只需要一个Draw Call便可完整绘制，内存的付出是值得的。</p>
<p><br></p>
<h2 id="2-5-另一种合并Texture的方式"><a href="#2-5-另一种合并Texture的方式" class="headerlink" title="2.5 另一种合并Texture的方式"></a>2.5 另一种合并Texture的方式</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Texture2D <span class="title">Combine</span>(<span class="params">Texture2D tex1, Texture2D tex2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> length = tex1.width * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> blcokBytes = <span class="number">0</span>; <span class="comment">// 和不同的压缩算法相关</span></span><br><span class="line">    <span class="built_in">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tex1.format)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.DXT1:</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.ETC_RGB4:</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.ETC2_RGB:</span><br><span class="line">            blcokBytes = <span class="number">8</span>;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">byte</span>[length / <span class="number">2</span> * length / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.DXT5:</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.ETC2_RGBA8:</span><br><span class="line">        <span class="keyword">case</span> TextureFormat.ASTC_4x4:</span><br><span class="line">            blcokBytes = <span class="number">16</span>;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">byte</span>[length * length / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            UnityEngine.Debug.Log(<span class="string">&quot;Not supported.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充第一张图到左边</span></span><br><span class="line">    CombineBlocks(tex1.GetRawTextureData(), data, <span class="number">0</span>, <span class="number">0</span>, tex1.width, <span class="number">4</span>, blcokBytes, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充第二张图到右边</span></span><br><span class="line">    CombineBlocks(tex2.GetRawTextureData(), data, tex1.width, <span class="number">0</span>, tex2.width, <span class="number">4</span>, blcokBytes, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并后的宽高要与两张图合并的尺寸一致</span></span><br><span class="line">    <span class="comment">// 这里简单把两张512 x 512的图合成一张大的1024 x 512</span></span><br><span class="line">    <span class="keyword">var</span> combinedTex = <span class="keyword">new</span> Texture2D(length, length / <span class="number">2</span>, tex1.format, <span class="literal">false</span>);</span><br><span class="line">    combinedTex.LoadRawTextureData(data);</span><br><span class="line">    combinedTex.Apply(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combinedTex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CombineBlocks</span>(<span class="params"><span class="built_in">byte</span>[] src, <span class="built_in">byte</span>[] dst, <span class="built_in">int</span> dstx, <span class="built_in">int</span> dsty, <span class="built_in">int</span> width, <span class="built_in">int</span> block, <span class="built_in">int</span> bytes, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> dstbx = dstx / block;</span><br><span class="line">    <span class="keyword">var</span> dstby = dsty / block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; width / block; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> dstindex = (dstbx + (dstby + i) * (length / block)) * bytes;</span><br><span class="line">        <span class="built_in">int</span> srcindex = i * (width / block) * bytes;</span><br><span class="line">        System.Buffer.BlockCopy(src, srcindex, dst, dstindex, width / block * bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>合并Texture应遵循：</strong></p>
<ul>
<li>Texture压缩格式一致</li>
<li>Texture为正方形且分辨率一致</li>
<li>申请合并后的Texture数组应和两张图合并的byte数一致，取决于不同压缩算法</li>
</ul>
<p>常见错误：</p>
<p>合并Texture时，新创建的数据集大于合并的数据集，报错:</p>
<ul>
<li><img src="2.5.jpg" alt="图2.5"></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/09/13/unity/mix/2D%E6%B8%B8%E6%88%8F%E7%9B%B8%E6%9C%BA%E8%B7%9F%E9%9A%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/13/unity/mix/2D%E6%B8%B8%E6%88%8F%E7%9B%B8%E6%9C%BA%E8%B7%9F%E9%9A%8F/" class="post-title-link" itemprop="url">2D游戏相机跟随</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-13 22:01:20 / 修改时间：22:03:04" itemprop="dateCreated datePublished" datetime="2023-09-13T22:01:20+08:00">2023-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Uniy/" itemprop="url" rel="index"><span itemprop="name">Uniy</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-矩形地图"><a href="#1-矩形地图" class="headerlink" title="1. 矩形地图"></a>1. 矩形地图</h1><h2 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h2><ol>
<li>初始化相机视野边界</li>
<li>相机跟随移动时，将相机视野限制在视野边界内</li>
</ol>
<h2 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h2><ol>
<li>初始化地图边界</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">public</span> SpriteRenderer m_Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用BoxCollider2D设置相机视野</span></span><br><span class="line"><span class="keyword">public</span> BoxCollider2D m_BoxCollider2D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> m_MinMapEdgeX = <span class="number">0</span>;  <span class="comment">// left edge of map in x</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> m_MaxMapEdgeX = <span class="number">0</span>;  <span class="comment">// right edge of map in x</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> m_MinMapEdgeY = <span class="number">0</span>;  <span class="comment">// bottom edge of map in y</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> m_MaxMapEdgeY = <span class="number">0</span>;  <span class="comment">// top edge of map in y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitMapBorder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.m_BoxCollider2D == <span class="literal">null</span> || <span class="keyword">this</span>.m_Map == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将实际边界减去相机size的宽高，计算出相机中心坐标的移动范围</span></span><br><span class="line">    <span class="keyword">var</span> mapExtents = <span class="keyword">this</span>.m_Map.bounds.extents;</span><br><span class="line">    <span class="keyword">var</span> cameraExtents = <span class="keyword">this</span>.m_BoxCollider2D.bounds.extents;</span><br><span class="line">    <span class="keyword">this</span>.m_MaxMapEdgeX = mapExtents.x - cameraExtents.x;</span><br><span class="line">    <span class="keyword">this</span>.m_MinMapEdgeX = -<span class="keyword">this</span>.m_MaxMapEdgeX;</span><br><span class="line">    <span class="keyword">this</span>.m_MaxMapEdgeY = mapExtents.y - cameraExtents.y;</span><br><span class="line">    <span class="keyword">this</span>.m_MinMapEdgeY = -<span class="keyword">this</span>.m_MaxMapEdgeY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>相机跟随</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform m_FollowTarget;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.m_FollowTarget != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> targetPosition = <span class="keyword">this</span>.m_FollowTarget.position + <span class="keyword">this</span>.m_Offset;</span><br><span class="line">        targetPosition = <span class="keyword">this</span>.GetLimitPosition(targetPosition);</span><br><span class="line">        <span class="keyword">this</span>.transform.position = targetPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坐标限制</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">GetLimitPosition</span>(<span class="params">Vector3 pos</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos.x &gt; <span class="keyword">this</span>.m_MaxMapEdgeX)</span><br><span class="line">        pos.x = <span class="keyword">this</span>.m_MaxMapEdgeX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos.x &lt; <span class="keyword">this</span>.m_MinMapEdgeX)</span><br><span class="line">        pos.x = <span class="keyword">this</span>.m_MinMapEdgeX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos.y &gt; <span class="keyword">this</span>.m_MaxMapEdgeY)</span><br><span class="line">        pos.y = <span class="keyword">this</span>.m_MaxMapEdgeY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos.y &lt; <span class="keyword">this</span>.m_MinMapEdgeY)</span><br><span class="line">        pos.y = <span class="keyword">this</span>.m_MinMapEdgeY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;/br&gt;</p>
<h1 id="2-多边形地图"><a href="#2-多边形地图" class="headerlink" title="2. 多边形地图"></a>2. 多边形地图</h1><h2 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h2><ol>
<li>移动实时计算相机的视野边界坐标</li>
<li>判断视野的上下左右边界是否在多边形内</li>
</ol>
<h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><ol>
<li>计算相机视野边界</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Camera m_Camera;</span><br><span class="line"></span><br><span class="line">Vector2 minCameraEdgeX = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0.5f</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// left edge of camera in x</span></span><br><span class="line">Vector2 maxCameraEdgeX = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0.5f</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// right edge of camera in x</span></span><br><span class="line">Vector2 minCameraEdgeY = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// bottom edge of camera in y</span></span><br><span class="line">Vector2 maxCameraEdgeY = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">1</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// top edge of camera in y</span></span><br></pre></td></tr></table></figure>
<ol>
<li>判断点是否在多边形内算法</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> ray-crossing算法，两点式方程公式：(y-y1)/(y2-y1)=(x-x1)/(x2-x1) 求位于直线上的点(x, y)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 判断点是否在多边形内.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 注意到如果从P作水平向右的射线的话，如果P在多边形内部，那么这条射线与多边形的交点必为奇数，</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 如果P在多边形外部，则交点个数必为偶数(0也在内)。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">PointIsInPolygon</span>(<span class="params"><span class="keyword">this</span> Vector2 point, Vector2[] polygon</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = polygon.Length;</span><br><span class="line">    <span class="keyword">var</span> point1 = Vector2.zero;</span><br><span class="line">    <span class="keyword">var</span> point2 = Vector2.zero;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        point1 = polygon[i];</span><br><span class="line">        point2 = polygon[(i + <span class="number">1</span>) % len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 水平边，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (point1.y == point2.y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点不在线段两端点范围内</span></span><br><span class="line">        <span class="keyword">if</span> (point.y &lt; Mathf.Min(point1.y, point2.y) | point.y &gt; Mathf.Max(point1.y, point2.y))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 经过点point，往右画一条直线，统计交点count次数</span></span><br><span class="line">        <span class="keyword">var</span> x = (point.y - point1.y) * (<span class="built_in">double</span>)(point2.x - point1.x) / (<span class="built_in">double</span>)(point2.y - point1.y) + point1.x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; point.x)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相交奇数次说明在多边形内</span></span><br><span class="line">    <span class="keyword">return</span> count % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>完整代码</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位标志</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> OutBoundType</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Left = <span class="number">0x0001</span>,</span><br><span class="line">    Right = <span class="number">0x0002</span>,</span><br><span class="line">    Up = <span class="number">0x0004</span>,</span><br><span class="line">    Bottom = <span class="number">0x0008</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollowForPolygonMap</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform m_FollowTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地图形状</span></span><br><span class="line">    <span class="keyword">public</span> Collider2D m_BoudingShape2D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Camera m_Camera;</span><br><span class="line">    <span class="keyword">private</span> Vector3 m_Offset;</span><br><span class="line">    <span class="keyword">private</span> Bounds m_Bounds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.m_Offset = <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.m_FollowTarget.position;</span><br><span class="line">        <span class="keyword">this</span>.m_Bounds = <span class="keyword">this</span>.m_BoudingShape2D.composite.bounds.size == Vector3.zero ? <span class="keyword">this</span>.m_BoudingShape2D.bounds : <span class="keyword">this</span>.m_BoudingShape2D.composite.bounds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.m_FollowTarget == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> targetPosition = <span class="keyword">this</span>.m_FollowTarget.position + <span class="keyword">this</span>.m_Offset;</span><br><span class="line">        <span class="keyword">var</span> lastPosition = <span class="keyword">this</span>.transform.position;</span><br><span class="line">        <span class="keyword">var</span> offset = targetPosition - lastPosition;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> boundType = GetCameraOutBoundTypeAfterMoving(offset);</span><br><span class="line">        <span class="keyword">if</span> (boundType.HasFlag(OutBoundType.Left) || boundType.HasFlag(OutBoundType.Right))</span><br><span class="line">            targetPosition.x = lastPosition.x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundType.HasFlag(OutBoundType.Bottom) || boundType.HasFlag(OutBoundType.Up))</span><br><span class="line">            targetPosition.y = lastPosition.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.transform.position = targetPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取相机移动后的越界类型, None: 未出界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> OutBoundType <span class="title">GetCameraOutBoundTypeAfterMoving</span>(<span class="params">Vector2 offset</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 minCameraEdgeX = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0.5f</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// left edge of camera in x</span></span><br><span class="line">        Vector2 maxCameraEdgeX = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0.5f</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// right edge of camera in x</span></span><br><span class="line">        Vector2 minCameraEdgeY = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// bottom edge of camera in y</span></span><br><span class="line">        Vector2 maxCameraEdgeY = <span class="keyword">this</span>.m_Camera.ViewportToWorldPoint(<span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">1</span>, <span class="keyword">this</span>.m_Camera.nearClipPlane)); <span class="comment">// top edge of camera in y</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里用的是Unity自带接口判断</span></span><br><span class="line">        <span class="keyword">var</span> ret = OutBoundType.None;</span><br><span class="line">        <span class="comment">// 左边越界</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.m_Bounds.Contains(minCameraEdgeX + offset))</span><br><span class="line">            ret = ret | OutBoundType.Left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右边出界</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.m_Bounds.Contains(maxCameraEdgeX + offset))</span><br><span class="line">            ret = ret | OutBoundType.Right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上边出界</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.m_Bounds.Contains(maxCameraEdgeY + offset))</span><br><span class="line">            ret = ret | OutBoundType.Up;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下边出界</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.m_Bounds.Contains(minCameraEdgeY + offset))</span><br><span class="line">            ret = ret | OutBoundType.Bottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/08/10/unity/JobSystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/10/unity/JobSystem/" class="post-title-link" itemprop="url">JobSystem</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-10 21:26:46 / 修改时间：21:42:23" itemprop="dateCreated datePublished" datetime="2023-08-10T21:26:46+08:00">2023-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Uniy/" itemprop="url" rel="index"><span itemprop="name">Uniy</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Unity的Job System可以很方便的编写多线程代码，多线程可以充分发挥多核的优势。可以单独使用，但为了提高性能，通常结合Burst编译器一起使用，这是专门为Unity的Job System编译作业而设计的。Burst编译器改进了代码生成，从而提高了性能并减少了移动设备上的电池消耗。也可以用在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">ECS</a>上，实现高性能的面向数据代码。</p>
<p>Job System的调度策略使用了工作窃取策略，以均匀分配跨工作线程共享的任务数量。思想是：成了所有任务的工作线程会查看其它工作线程的任务队列，然后将任务分配给另一个工作线程。</p>
<p><br></p>
<h1 id="2-Job-Types"><a href="#2-Job-Types" class="headerlink" title="2. Job Types"></a>2. Job Types</h1><ol>
<li>IJob：在job thread运行的单个任务</li>
<li>IJobFor：与IJobParallelFor相同，但允许调度Job，使其不会并行运行</li>
<li>IJobParallelFor：并行运行任务。每个并行运行的工作线程都有一个独占索引，以便安全地访问工作线程之间的共享数据</li>
</ol>
<h2 id="2-1-IJob"><a href="#2-1-IJob" class="headerlink" title="2.1 IJob"></a>2.1 IJob</h2><p>定义一个Job：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Job中的变量仅可以使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blittable_types">blittable types</a>或者Unity提供的NativeContainer容器，比如引擎内置的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html">NativeArray</a>或者<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.collections@1.2/manual/index.html">com.unity.collections package</a>中提供的容器类。</p>
<pre>
为什么只能使用blittable types？

为了资源竞争问题，Job System向每个任务发送它需要操作的数据的副本，而不是主线程中对数据的引用。该副本隔离了数据，从而消除了竞争条件。blittable types在这个拷贝过程中不需要做数据转换，因此blittable types在这里是必须的。
</pre>

<p>Job调度：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> AddJob()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>,</span><br><span class="line">        b = <span class="number">2</span>,</span><br><span class="line">        result = <span class="keyword">this</span>._result</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调度</span></span><br><span class="line">    <span class="keyword">this</span>._handler = job.Schedule();</span><br><span class="line">    <span class="comment">// 调用Complete获取结果</span></span><br><span class="line">    <span class="keyword">this</span>._handler.Complete();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Start _result = <span class="subst">&#123;<span class="keyword">this</span>._result[<span class="number">0</span>]&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddJob</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NativeArray&lt;<span class="built_in">float</span>&gt; _result;</span><br><span class="line">    <span class="keyword">private</span> JobHandle _handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._result = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">float</span>&gt;(<span class="number">1</span>, Allocator.Persistent);</span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> AddJob()</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">1</span>,</span><br><span class="line">            b = <span class="number">2</span>,</span><br><span class="line">            result = <span class="keyword">this</span>._result</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>._handler = job.Schedule();</span><br><span class="line">        <span class="keyword">this</span>._handler.Complete();</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Start _result = <span class="subst">&#123;<span class="keyword">this</span>._result[<span class="number">0</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void Update()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (this._handler.IsCompleted)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         this._handler.Complete();</span></span><br><span class="line">    <span class="comment">//         Debug.Log($&quot;Update _result = &#123;this._result[0]&#125;&quot;);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放非托管资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._result.IsCreated)</span><br><span class="line">            <span class="keyword">this</span>._result.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="2-2-IJobFor"><a href="#2-2-IJobFor" class="headerlink" title="2.2 IJobFor"></a>2.2 IJobFor</h2><p>与对比IJobFor：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IJobFor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IJob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IJobFor接口的Execute方法多了一个index参数，通过这个参数可以访问Job中的NativeContainer容器，对容器中的元素进行相对独立的操作。除此之外，IJobFor还在任务的调度上提供了更大的灵活性。可以用下面三种方式调度Job：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> position = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(<span class="number">500</span>, Allocator.Persistent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> VelocityJob();</span><br><span class="line">    <span class="comment">// run on main thread</span></span><br><span class="line">    job.Run(position.Length);</span><br><span class="line">    <span class="comment">// run on a single worker thread</span></span><br><span class="line">    job.Schedule(position.Length, dependency);</span><br><span class="line">    <span class="comment">// run on parallel worker threads</span></span><br><span class="line">    job.ScheduleParallel(position.Length, <span class="number">64</span>, dependency);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三种方式都需要传入一个arrayLength参数，这个参数可以控制Execute方法执行的次数。 实际上传入的arrayLength不一定就是数组的长度，它可以是小于数组长度的任意数值。<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobFor.html">Unity官方例子</a>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApplyVelocityParallelForSample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> VelocityJob : IJobFor</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// By declaring it as read only, multiple jobs are allowed to access the data in parallel</span></span><br><span class="line">        [<span class="meta">ReadOnly</span>]</span><br><span class="line">        <span class="keyword">public</span> NativeArray&lt;Vector3&gt; velocity;</span><br><span class="line">        <span class="comment">// By default containers are assumed to be read &amp; write</span></span><br><span class="line">        <span class="keyword">public</span> NativeArray&lt;Vector3&gt; position;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            position[i] = position[i] + velocity[i] * deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> position = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(<span class="number">500</span>, Allocator.Persistent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> velocity = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(<span class="number">500</span>, Allocator.Persistent);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; velocity.Length; i++)</span><br><span class="line">            velocity[i] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> VelocityJob()</span><br><span class="line">        &#123;</span><br><span class="line">            deltaTime = Time.deltaTime,</span><br><span class="line">            position = position,</span><br><span class="line">            velocity = velocity</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// run on main thread</span></span><br><span class="line">        job.Run(position.Length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//run on a single worker thread</span></span><br><span class="line">        <span class="keyword">var</span> sheduleJobDependency = <span class="keyword">new</span> JobHandle();</span><br><span class="line">        <span class="keyword">var</span> sheduleJobHandle = job.Schedule(position.Length, sheduleJobDependency);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//run on parallel worker threads</span></span><br><span class="line">        <span class="keyword">var</span> sheduleParralelJobHandle = job.ScheduleParallel(position.Length, <span class="number">64</span>, sheduleJobHandle);</span><br><span class="line"></span><br><span class="line">        sheduleParralelJobHandle.Complete();</span><br><span class="line"></span><br><span class="line">        Debug.Log(job.position[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        position.Dispose();</span><br><span class="line">        velocity.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
把velocity标记为ReadOnly时，可以在多个并行的Job中读取velocity数组的内容而不触发safety system。因此应该尽量将Job中只读的数据标记成ReadOnly来最大化性能。
</pre>

<p>IJobFor的三种不同用法在性能上的表现截图：</p>
<ul>
<li><img src="2.2.jpg" alt="图2.2"></li>
</ul>
<ol>
<li>Job.Run：行在主线程的</li>
<li>Job.Schedule：由于任务窃取的调度策略Job.Schedule也在主线程，当主线程在等待工作（worker）线程执行的过程中也会从任务池中获取任务来执行，从而加快所有任务的完成进度</li>
<li>Job.ScheduleParallel：时间明显要短于前两个，通过ScheduleParallel把任务分发到各个工作线程，让每个线程负责一部分工作</li>
</ol>
<p>应该尽量使用IJobFor.ScheduleParallel来把任务拆分到多个核心去做并行计算，才能最大化程序的执行效率。</p>
<p><br></p>
<h1 id="3-线程本地资源"><a href="#3-线程本地资源" class="headerlink" title="3. 线程本地资源"></a>3. 线程本地资源</h1><p>应用场景：每次随机一个方向进行移动：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> RandomVelocityJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">float</span>&gt; speeds;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] </span><br><span class="line">    <span class="keyword">public</span> Random random;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        positions[i] += random.NextFloat3Direction() * speeds[i] * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> random = <span class="keyword">new</span> Random(<span class="number">1234</span>);</span><br><span class="line"><span class="keyword">var</span> randomVelocityJob = <span class="keyword">new</span> RandomVelocityJob</span><br><span class="line">&#123;</span><br><span class="line">    speeds = m_Speeds,</span><br><span class="line">    random = random,</span><br><span class="line">    positions = m_Positions,</span><br><span class="line">    deltaTime = Time.deltaTime,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>NextFloat3Direction方法会改变random的内部状态，由于所有的worker线程会共享并改变random的状态，使random处在竞争条件的状态。加锁是效率比较低的方法，另外一种比较经典的做法是使用线程本地存储（TLS），让每个线程拥有一份自己独有的资源，避免了竞争条件的问题。</p>
<p>使用JobsUtility.MaxJobThreadCount来获取worker的最大数量，为每一个worker线程初始化一个random变量：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NativeArray&lt;Random&gt; _randoms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._randoms = <span class="keyword">new</span> NativeArray&lt;Random&gt;(JobsUtility.MaxJobThreadCount, Allocator.Persistent);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Randoms.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    _randoms[i] = Random.CreateFromIndex((<span class="built_in">uint</span>)i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Job中需要知道当前执行的线程ID，可以在Job中声明一个int类型的变量并添加[NativeSetThreadIndex]属性，在job执行的过程中Unity会自动注入Job ID。 这样就可以在Execute方法中利用线程ID获取线程独有的资源了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> RandomVelocityJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">float</span>&gt; speeds;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] </span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;Random&gt; randoms;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动注入线程Id</span></span><br><span class="line">    [<span class="meta">NativeSetThreadIndex</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> threadIdx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        positions[i] += randoms[threadIdx].NextFloat3Direction() * speeds[i] * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="4-Pointers-amp-InterLocked"><a href="#4-Pointers-amp-InterLocked" class="headerlink" title="4. Pointers &amp; InterLocked"></a>4. Pointers &amp; InterLocked</h1><p>利用IJobFor接口开实现并行求和：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> NaiveParallelCounterJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这断代码会导致任务完成之后无法获取正确的sum值，因为sum不是以引用的形式传进来的而是直接以值传递的形式进行了赋值，修改：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> NaiveParallelCounterJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; data;</span><br><span class="line">    <span class="comment">// 允许以引用的方式来传递单个值</span></span><br><span class="line">    <span class="keyword">public</span> NativeReference&lt;<span class="built_in">int</span>&gt; naiveSum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        naiveSum.Value += data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Job在多线程中运行时，对naiveSum变量的访问可能会存在竞争条件，使用TLS解决：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ThreadLocalParallelCounterJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    [<span class="meta">NativeDisableParallelForRestriction</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    [<span class="meta">NativeDisableParallelForRestriction</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">NativeSetThreadIndex</span>] <span class="keyword">private</span> <span class="built_in">int</span> _threadIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sums[_threadIndex] += data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TotalSumJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NativeReference&lt;<span class="built_in">int</span>&gt; totalSum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            totalSum.Value += sums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job依赖</span></span><br><span class="line"><span class="keyword">var</span> threadLocalCounterJobHandle = threadLocalCounterJob.ScheduleParallel(m_Data.Length, <span class="number">64</span>, <span class="keyword">new</span> JobHandle());</span><br><span class="line"><span class="keyword">var</span> totalSumJobHandle = totalSumJob.Schedule(threadLocalCounterJobHandle);</span><br><span class="line"></span><br><span class="line">totalSumJobHandle.Complete();</span><br></pre></td></tr></table></figure>
<p>使用Interlocked实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">struct</span> InterlockedParallelCounterJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeArray</span>&lt;<span class="title">int</span>&gt; data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    [<span class="meta">NativeDisableUnsafePtrRestriction</span>] <span class="keyword">public</span> <span class="built_in">int</span>* sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Interlocked.Add(<span class="keyword">ref</span> UnsafeUtility.AsRef&lt;<span class="built_in">int</span>&gt;(sum), data[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-6.0">Interlocked</a>可以在不同线程之间以原子操作的方式来修改变量，这样就不用担心竞争条件的问题了。为了在Job中使用指针，需要引入一个新的属性——[NativeDisableUnsafePtrRestriction]。</p>
<p>完整代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections.LowLevel.Unsafe;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs.LowLevel.Unsafe;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">ParallelCounter</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> ThreadLocalParallelCounterJob : IJobFor</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//input</span></span><br><span class="line">        [<span class="meta">NativeDisableParallelForRestriction</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        [<span class="meta">NativeDisableParallelForRestriction</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">NativeSetThreadIndex</span>] <span class="keyword">private</span> <span class="built_in">int</span> m_ThreadIndex;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            sums[m_ThreadIndex] += data[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> TotalSumJob : IJob</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; totalSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sums.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                totalSum[<span class="number">0</span>] += sums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">struct</span> InterlockedParallelCounterJob : IJobFor</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//input</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NativeArray</span>&lt;<span class="title">int</span>&gt; data</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        [<span class="meta">NativeDisableUnsafePtrRestriction</span>] <span class="keyword">public</span> <span class="built_in">int</span>* sum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Interlocked.Add(<span class="keyword">ref</span> UnsafeUtility.AsRef&lt;<span class="built_in">int</span>&gt;(sum), data[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> DATA_COUNT = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> NativeArray&lt;<span class="built_in">int</span>&gt; _data;</span><br><span class="line">    <span class="keyword">private</span> NativeArray&lt;<span class="built_in">int</span>&gt; _threadLocalSums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._data = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(DATA_COUNT, Allocator.Persistent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; DATA_COUNT; i++)</span><br><span class="line">            <span class="keyword">this</span>._data[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._threadLocalSums = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(JobsUtility.MaxJobThreadCount, Allocator.Persistent);</span><br><span class="line">        ResetThreadLocalSums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetThreadLocalSums</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._threadLocalSums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._threadLocalSums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._data.Dispose();</span><br><span class="line">        <span class="keyword">this</span>._threadLocalSums.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> threadLocalCounterJob = <span class="keyword">new</span> ThreadLocalParallelCounterJob</span><br><span class="line">        &#123;</span><br><span class="line">            data = <span class="keyword">this</span>._data,</span><br><span class="line">            sums = <span class="keyword">this</span>._threadLocalSums</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> totalSum = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> totalSumJob = <span class="keyword">new</span> TotalSumJob</span><br><span class="line">        &#123;</span><br><span class="line">            sums = <span class="keyword">this</span>._threadLocalSums,</span><br><span class="line">            totalSum = totalSum</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> threadLocalCounterJobHandle = threadLocalCounterJob.ScheduleParallel(<span class="keyword">this</span>._data.Length, <span class="number">64</span>, <span class="keyword">new</span> JobHandle());</span><br><span class="line">        <span class="keyword">var</span> totalSumJobHandle = totalSumJob.Schedule(threadLocalCounterJobHandle);</span><br><span class="line"></span><br><span class="line">        totalSumJobHandle.Complete();</span><br><span class="line"></span><br><span class="line">        ResetThreadLocalSums();</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">$&quot;[ThreadLocalParallelCounter] Sum = <span class="subst">&#123;totalSum[<span class="number">0</span>]&#125;</span>&quot;</span>);</span><br><span class="line">        totalSum.Dispose();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = (<span class="built_in">int</span>*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf&lt;<span class="built_in">int</span>&gt;(), UnsafeUtility.AlignOf&lt;<span class="built_in">int</span>&gt;(), Allocator.TempJob);</span><br><span class="line">        *sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> interlockedParallelCounterJob = <span class="keyword">new</span> InterlockedParallelCounterJob</span><br><span class="line">        &#123;</span><br><span class="line">            data = <span class="keyword">this</span>._data,</span><br><span class="line">            sum = sum</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> interlockedCounterJobHandle = interlockedParallelCounterJob.ScheduleParallel(<span class="keyword">this</span>._data.Length, <span class="number">64</span>, <span class="keyword">new</span> JobHandle());</span><br><span class="line">        interlockedCounterJobHandle.Complete();</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">$&quot;[InterlockedParallelCounterJob] Sum = <span class="subst">&#123;*sum&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UnsafeUtility.Free(sum, Allocator.TempJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="5-innerloopBatchCount"><a href="#5-innerloopBatchCount" class="headerlink" title="5. innerloopBatchCount"></a>5. innerloopBatchCount</h1><p>官方说明：innerloopBatchCount是执行任务窃取的粒度。并在这个worker线程中连续调用innerloopBatchCount次的Execute(index)方法。当每次迭代中都有大量工作时，将值设为1是合理的。反之设置为32或64是合理的。</p>
<p>测试不同batchCount对性能的影响：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> job = <span class="keyword">new</span> VelocityJob()</span><br><span class="line">&#123;</span><br><span class="line">    deltaTime = Time.deltaTime,</span><br><span class="line">    position = _positions,</span><br><span class="line">    velocity = _velocity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batchCount = <span class="number">1</span>;</span><br><span class="line">Profiler.BeginSample(<span class="string">$&quot;Batch = <span class="subst">&#123;batchCount&#125;</span>&quot;</span>);</span><br><span class="line">job.ScheduleParallel(_positions.Length, batchCount, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">batchCount = <span class="number">8</span>;</span><br><span class="line">Profiler.BeginSample(<span class="string">$&quot;Batch = <span class="subst">&#123;batchCount&#125;</span>&quot;</span>);</span><br><span class="line">job.ScheduleParallel(_positions.Length, batchCount, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">batchCount = <span class="number">16</span>;</span><br><span class="line">Profiler.BeginSample(<span class="string">$&quot;Batch = <span class="subst">&#123;batchCount&#125;</span>&quot;</span>);</span><br><span class="line">job.ScheduleParallel(_positions.Length, batchCount, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">batchCount = <span class="number">32</span>;</span><br><span class="line">Profiler.BeginSample(<span class="string">$&quot;Batch = <span class="subst">&#123;batchCount&#125;</span>&quot;</span>);</span><br><span class="line">job.ScheduleParallel(m_Positions.Length, batchCount, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">batchCount = <span class="number">64</span>;</span><br><span class="line">Profiler.BeginSample(<span class="string">$&quot;Batch = <span class="subst">&#123;batchCount&#125;</span>&quot;</span>);</span><br><span class="line">job.ScheduleParallel(_positions.Length, batchCount, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">Profiler.EndSample();</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<ul>
<li><img src="5.1.jpg" alt="图5.1"></li>
</ul>
<p>Batch=1时性能最差，Batch=8时性能稍好，当Batch为8的整数倍时，性能是相近的。出现这个现象的原因是伪共享。CPU缓存结构：</p>
<ul>
<li><img src="5.2.jpg" alt="图5.2"></li>
</ul>
<p>一个 CPU 里通常会有多个 CPU 核心，如上图中的 CPU1 和 CPU2，并且每个 CPU 核心都有自己的 L1 Cache 和 L2 Cache，而 L1 Cache 通常分为 DCache（数据缓存） 和 ICache（指令缓存），L3 Cache 则是多个核心共享的。</p>
<p>伪共享产生的原因：</p>
<p>由于缓存读取的机制，不是一次只读一个数据，而是一次读取一个CacheLine的数据。如果有两个CPU同时访问到内存中的同一个CachLine数据时，CacheLine会同时被加载进入CPU1和CPU2中。由于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MESI_protocol">MESI</a>协议，CPU1修改数据时，CPU2所共享的CacheLine将会失效，CPU2只能等到CPU1修改完后，再重新获取CacheLine并修改。这样就导致了CPU2运行效率的降低。这个问题就是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a>。</p>
<p>Batch=1便是伪共享导致效率低下，分析Batch数为8的整数倍时运行效率几乎一样的原因：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> VelocityJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;float3&gt; velocity;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;float3&gt; position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        position[i] += velocity[i] * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>velocity和position都是float3类型，大小是4 <em> 3 = 12字节，电脑的cache line大小是32字节，得出 12 </em> 8 == 32 * 3 == 96，因此当batch大小是8的倍数时恰好可以避免伪共享（false sharing）问题，因此时间几乎一致。</p>
<p><br></p>
<h1 id="6-SoA-vs-AoS"><a href="#6-SoA-vs-AoS" class="headerlink" title="6. SoA vs AoS"></a>6. SoA vs AoS</h1><p>array of structures (AoS)和structure of arrays (SoA)代表两种不同的数据组织形式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AoSData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SoAData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; aArray;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; bArray;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; cArray;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; dArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存布局：</p>
<ul>
<li><img src="6.1.jpg" alt="图6.1"></li>
</ul>
<p>AoSData的数据a，b，c，d在内存中是交错存在的。而SoAData中相同的数据在内存中是连续存在的。两种形式对于数据访问的性能：</p>
<p>假设a，b，c，d四个数据的大小是一样的并且当前CPU的cache line一次可以加载4个数据即一个cache line可以加载a，b，c，d或者a，a，a，b四个数据。使用AoSData的情况下访问所有的a数据需要访问3次内存：</p>
<ol>
<li>加载abcd，找到第一个a</li>
<li>加载abcd，找到第二个a</li>
<li>加载abcd，找到第三个a</li>
</ol>
<p>使用SoAData只需要一次，加载aaab，找到三个a。且SoA对SIMD指令更加友好，Burst对SoA形式的数据也有特别的支持，都能让SoAData具有更好的性能，编码测试。</p>
<p>数据定义：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unity中典型的AoS和SoA数据的组织形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TransformAoS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> float3 position;</span><br><span class="line">    <span class="keyword">public</span> quaternion rotation;</span><br><span class="line">    <span class="keyword">public</span> float3 scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransformSoA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;quaternion&gt; rotations;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;float3&gt; scales;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AoS的Job实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TransformAoSJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;TransformAoS&gt; transformAoSes;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> float3 velocity;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> transAoS = transformAoSes[index];</span><br><span class="line">        transAoS.position += velocity * deltaTime;</span><br><span class="line">        transformAoSes[index] = transAoS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>var transAoS = transformAoSes[index]会产生一次结构体拷贝，结构体比较小的时候性能开销并不高，但是当结构体中数据量比较大的时候，开销也会升高。由于transAoS是一个拷贝副本，因此对它的修改不会反映在数据本体上，所以在Job的最后把拷贝出来的值又赋值回了transformAoSes数组，又产生了一次数据拷贝。利用指针来获取原始数据的引用改进代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TransformAoSJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;TransformAoS&gt; transformAoSes;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> float3 velocity;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// var transAoS = transformAoSes[index];</span></span><br><span class="line">        <span class="comment">// transAoS.position += velocity * deltaTime;</span></span><br><span class="line">        <span class="comment">// transformAoSes[index] = transAoS;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> transformPtr = (TransformAoS*)transformAoSes.GetUnsafePtr();</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">var</span> transform = <span class="keyword">ref</span> transformPtr[index];</span><br><span class="line">        transform.position += velocity * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SoA的Job实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TransformSoAJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">NoAlias</span>] <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> float3 velocity;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        positions[index] += velocity * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.burst@1.6/manual/index.html">Burst编译</a>，否则无差别，没使用BurstCompile的性能对比：</p>
<ul>
<li><img src="6.2.jpg" alt="图6.2"></li>
</ul>
<p>BurstCompile性能对比：</p>
<ul>
<li><img src="6.3.jpg" alt="图6.3"></li>
</ul>
<p>完整代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Burst;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections.LowLevel.Unsafe;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Random = Unity.Mathematics.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">JobSystem.SoA_VS_AoS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> TransformAoS</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> float3 position;</span><br><span class="line">        <span class="keyword">public</span> quaternion rotation;</span><br><span class="line">        <span class="keyword">public</span> float3 scale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">TransformBehaviour</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransformSoA</span> : <span class="title">IDisposable</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line">            <span class="keyword">public</span> NativeArray&lt;quaternion&gt; rotations;</span><br><span class="line">            <span class="keyword">public</span> NativeArray&lt;float3&gt; scales;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TransformSoA</span>(<span class="params"><span class="built_in">int</span> count</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Create(count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"><span class="built_in">int</span> count</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                positions = <span class="keyword">new</span> NativeArray&lt;float3&gt;(count, Allocator.Persistent);</span><br><span class="line">                rotations = <span class="keyword">new</span> NativeArray&lt;quaternion&gt;(count, Allocator.Persistent);</span><br><span class="line">                scales = <span class="keyword">new</span> NativeArray&lt;float3&gt;(count, Allocator.Persistent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (positions.IsCreated)</span><br><span class="line">                    positions.Dispose();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rotations.IsCreated)</span><br><span class="line">                    rotations.Dispose();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (scales.IsCreated)</span><br><span class="line">                    scales.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">BurstCompile</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> TransformAoSJob : IJobFor</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> NativeArray&lt;TransformAoS&gt; transformAoSes;</span><br><span class="line">            [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> float3 velocity;</span><br><span class="line">            [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> transformPtr = (TransformAoS*)transformAoSes.GetUnsafePtr();</span><br><span class="line">                <span class="keyword">ref</span> <span class="keyword">var</span> transform = <span class="keyword">ref</span> transformPtr[index];</span><br><span class="line">                transform.position += velocity * deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">BurstCompile</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> TransformSoAJob : IJobFor</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> NativeArray&lt;float3&gt; positions;</span><br><span class="line">            [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> float3 velocity;</span><br><span class="line">            [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> positionPtr = (float3*)positions.GetUnsafePtr();</span><br><span class="line">                <span class="keyword">ref</span> <span class="keyword">var</span> position = <span class="keyword">ref</span> positionPtr[index];</span><br><span class="line">                position += velocity * deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NativeArray&lt;TransformAoS&gt; m_TransformAoSes;</span><br><span class="line">        <span class="keyword">private</span> TransformSoA m_TransformSoA;</span><br><span class="line">        <span class="keyword">private</span> float3 m_Velocity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> TRANSFORM_COUNT = <span class="number">5000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_TransformAoSes = <span class="keyword">new</span> NativeArray&lt;TransformAoS&gt;(TRANSFORM_COUNT, Allocator.Persistent);</span><br><span class="line">            m_TransformSoA = <span class="keyword">new</span> TransformSoA(TRANSFORM_COUNT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> transformAoSPtr = (TransformAoS*)m_TransformAoSes.GetUnsafePtr();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> rand = <span class="keyword">new</span> Random(<span class="number">1332</span>);</span><br><span class="line"></span><br><span class="line">            m_Velocity = rand.NextFloat3Direction();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TRANSFORM_COUNT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">ref</span> <span class="keyword">var</span> transAoS = <span class="keyword">ref</span> transformAoSPtr[i];</span><br><span class="line">                transAoS.position = rand.NextFloat3();</span><br><span class="line">                transAoS.rotation = rand.NextQuaternionRotation();</span><br><span class="line">                transAoS.scale = <span class="keyword">new</span> float3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                m_TransformSoA.positions[i] = rand.NextFloat3();</span><br><span class="line">                m_TransformSoA.rotations[i] = rand.NextQuaternionRotation();</span><br><span class="line">                m_TransformSoA.scales[i] = <span class="keyword">new</span> float3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_TransformAoSes.Dispose();</span><br><span class="line">            m_TransformSoA.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> TransformSoAJob</span><br><span class="line">            &#123;</span><br><span class="line">                positions = m_TransformSoA.positions,</span><br><span class="line">                velocity = m_Velocity,</span><br><span class="line">                deltaTime = Time.deltaTime</span><br><span class="line">            &#125;.ScheduleParallel(m_TransformSoA.positions.Length, <span class="number">64</span>, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> TransformAoSJob</span><br><span class="line">            &#123;</span><br><span class="line">                transformAoSes = m_TransformAoSes,</span><br><span class="line">                velocity = m_Velocity,</span><br><span class="line">                deltaTime = Time.deltaTime</span><br><span class="line">            &#125;.ScheduleParallel(m_TransformAoSes.Length, <span class="number">64</span>, <span class="keyword">new</span> JobHandle()).Complete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/08/07/graphic/opengl/%E9%A2%9C%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/07/graphic/opengl/%E9%A2%9C%E8%89%B2/" class="post-title-link" itemprop="url">颜色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-07 21:20:14 / 修改时间：21:51:31" itemprop="dateCreated datePublished" datetime="2023-08-07T21:20:14+08:00">2023-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>颜色空间有RGB、CMYK、LAB、HSV等，其中RGB是游戏中最常用的。它由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，通常每个分量用8位存储，则rgb可表示2的24次方种颜色。用这三个值就可以组合出任意一种颜色，例如需要白色，可以定义如下颜色向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">white</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现实生活中能看到物体的颜色并不是物体真的由颜色，而是物体表面无法吸收而反射的颜色。太阳光是由多种不同颜色的光组成的白色，照射到红色物体后，它会吸收除了红色以外的所有颜色，不能吸收的将被反射，最后进入人眼，因此看到的都是物体反射的颜色，如下：</p>
<ul>
<li><img src="颜色_1.jpg" alt="图1.1"></li>
</ul>
<p>图形渲染中反射颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 白光</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 物体颜色反射系数</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 结果(1.0f, 0.0f, 0.0f);</span></span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br></pre></td></tr></table></figure>
<p>物体根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射，也表现了现实中颜色的工作原理。由此，可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。改变光照颜色也可以改变物体的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绿光</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 物体颜色反射系数</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 结果(0.0f, 0.0f, 0.0f);</span></span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="2-创建光照场景"><a href="#2-创建光照场景" class="headerlink" title="2. 创建光照场景"></a>2. 创建光照场景</h1><p>光源的顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光源的片段着色器，让它一直呈现白色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将向量的四个分量全部设置为1.0</span></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>物体的顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>物体的片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lightColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染光源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光源位置</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物体</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO, cubeVAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;cubeVAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光源</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lightCubeVAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightCubeVAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(lightCubeVAO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染物体</span></span><br><span class="line">cubeShader.<span class="built_in">use</span>();</span><br><span class="line">cubeShader.<span class="built_in">setVec3</span>(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">cubeShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.Zoom), (<span class="type">float</span>)SCR_WIDTH / (<span class="type">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line"></span><br><span class="line">glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染光源</span></span><br><span class="line">lightShader.<span class="built_in">use</span>();</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">model = glm::<span class="built_in">translate</span>(model, lightPos);</span><br><span class="line">model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br><span class="line">cubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(lightCubeVAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="颜色_2.jpg" alt="图2.1"></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/29/graphic/opengl/%E6%91%84%E5%83%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/29/graphic/opengl/%E6%91%84%E5%83%8F%E6%9C%BA/" class="post-title-link" itemprop="url">摄像机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-29 10:12:24 / 修改时间：11:31:34" itemprop="dateCreated datePublished" datetime="2023-07-29T10:12:24+08:00">2023-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-构建摄像机"><a href="#1-构建摄像机" class="headerlink" title="1. 构建摄像机"></a>1. 构建摄像机</h1><h2 id="1-1-确定位置"><a href="#1-1-确定位置" class="headerlink" title="1.1 确定位置"></a>1.1 确定位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure>
<h2 id="1-2-确定z轴"><a href="#1-2-确定z轴" class="headerlink" title="1.2 确定z轴"></a>1.2 确定z轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让摄像机指向场景原点</span></span><br><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// 向量相减，让相机的z轴正方向看向世界的z轴负方向</span></span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure>
<h2 id="1-3-确定x轴"><a href="#1-3-确定x轴" class="headerlink" title="1.3 确定x轴"></a>1.3 确定x轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个上向量</span></span><br><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// y,z叉乘得到x轴正方向</span></span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br></pre></td></tr></table></figure>
<h2 id="1-4-确定y轴"><a href="#1-4-确定y轴" class="headerlink" title="1.4 确定y轴"></a>1.4 确定y轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z,x叉乘得到y轴正方向</span></span><br><span class="line">glm::vec3 cameraUp = glm::<span class="built_in">cross</span>(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure>
<p>摄像机坐标系如图：</p>
<ul>
<li><img src="摄像机_1.jpg" alt="图1.4.1"></li>
</ul>
<p><br></p>
<h1 id="2-GLM构建观察空间矩阵"><a href="#2-GLM构建观察空间矩阵" class="headerlink" title="2. GLM构建观察空间矩阵"></a>2. GLM构建观察空间矩阵</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 传入摄像机位置，目标方向，和向上向量构建观察矩阵</span></span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>
<p>实现相机绕原点旋转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 半径</span></span><br><span class="line"><span class="type">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="comment">// 画圆</span></span><br><span class="line"><span class="type">float</span> camX = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line"><span class="type">float</span> camZ = <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="摄像机_2.gif" alt="图2.1"></li>
</ul>
<p><br></p>
<h1 id="3-自由移动"><a href="#3-自由移动" class="headerlink" title="3. 自由移动"></a>3. 自由移动</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>); <span class="comment">// 看向z轴负方向</span></span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察矩阵始终看向z轴负方向</span></span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, cameraPos + cameraFront, cameraUp);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听键盘输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">0.05f</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed; <span class="comment">// 减去叉乘得到x轴正方向，往左移动, normalize保证匀速</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed; <span class="comment">// 加上叉乘得到x轴正方向，往右移动, normalize保证匀速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整移动速度：</p>
<p>根据处理器的能力不同，不能保证不同设备每秒绘制相同帧数。导致配置的不同，有些人可能移动很快，而有些人会移动很慢。实现不同设备匀速：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="type">float</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 上一帧的时间</span></span><br><span class="line"><span class="type">float</span> lastFrame = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="comment">// 更新渲染当前帧花费的时间</span></span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用时间去平衡速度：帧率高的deltaTime小，速度慢，帧率低的deltaTime大，速度快</span></span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="摄像机_3.gif" alt="图3.1"></li>
</ul>
<p><br></p>
<h1 id="4-视角移动"><a href="#4-视角移动" class="headerlink" title="4. 视角移动"></a>4. 视角移动</h1><h2 id="4-1-欧拉角"><a href="#4-1-欧拉角" class="headerlink" title="4.1 欧拉角"></a>4.1 欧拉角</h2><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，如下图：</p>
<ul>
<li><img src="摄像机_4.jpg" alt="图4.1"></li>
</ul>
<p>游戏中的摄像机比较少使用到滚转角，此处推导经过俯仰角和偏航角后摄像机的方向：</p>
<ul>
<li><img src="摄像机_5.jpg" alt="图4.2"></li>
</ul>
<p>可得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由相机初始看向x正半轴推导出来的相机新的方向</span></span><br><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br></pre></td></tr></table></figure>
<p>可以用用旋转矩阵进行推导，出现结果不一致可参考<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/1791209/euler-angle-to-direction-vector-which-is-right">链接</a>。</p>
<h2 id="4-2-鼠标输入"><a href="#4-2-鼠标输入" class="headerlink" title="4.2 鼠标输入"></a>4.2 鼠标输入</h2><p>通过鼠标的移动来控制镜头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上一次鼠标位置</span></span><br><span class="line"><span class="type">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏光标</span></span><br><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听鼠标输入</span></span><br><span class="line"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 防止首次抖动</span></span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算x,y偏移</span></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灵敏度</span></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    <span class="comment">// 偏移乘上灵敏系数，获得合适的改变幅度</span></span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将偏移加到仰俯，偏航角上</span></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制极限情况(在90度时视角会发生逆转)</span></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用公式计算新的相机方向</span></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-缩放"><a href="#4-3-缩放" class="headerlink" title="4.3 缩放"></a>4.3 缩放</h2><p>缩放的原理是改变fov视野大小，当视野变小时，场景投影出来的空间就会减小，产生放大的感觉，视野变大则相反，代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 监听鼠标滚轮输入</span></span></span><br><span class="line"><span class="function"><span class="title">glfwSetScrollCallback</span><span class="params">(window, scroll_callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov -= yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新投影矩阵的视野</span></span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="摄像机_6.gif" alt="图4.3"></li>
</ul>
<p><br></p>
<h1 id="5-摄像机类"><a href="#5-摄像机类" class="headerlink" title="5. 摄像机类"></a>5. 摄像机类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/detail/type_vec.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机移动方向</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Camera_Movement</span> &#123;</span><br><span class="line">    FORWARD,</span><br><span class="line">    BACKWARD,</span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认偏航角</span></span><br><span class="line"><span class="comment">// 由于公式用的初态相机位置看向x轴正方向，因此偏航-90度，让相机看向z轴负方向</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> YAW = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="comment">// 默仰俯角</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PITCH = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 默认移动速度</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SPEED = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">// 默认鼠标灵敏系数，影响旋转</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SENSITIVITY = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">// 默认缩放视野</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> ZOOM = <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 位置</span></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    <span class="comment">// 向前方向 z轴</span></span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    <span class="comment">// 向上方向 y轴</span></span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    <span class="comment">// 向右方向 x轴</span></span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    <span class="comment">// 世界的上方向</span></span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧拉角</span></span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它属性</span></span><br><span class="line">    <span class="type">float</span> MovementSpeed;</span><br><span class="line">    <span class="type">float</span> MouseSensitivity;</span><br><span class="line">    <span class="type">double</span> Zoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Camera</span>(glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), <span class="type">float</span> yaw = YAW, <span class="type">float</span> pitch = PITCH) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = position;</span><br><span class="line">        WorldUp = up;</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="type">float</span> posX, <span class="type">float</span> posY, <span class="type">float</span> posZ, <span class="type">float</span> upX, <span class="type">float</span> upY, <span class="type">float</span> upZ, <span class="type">float</span> yaw, <span class="type">float</span> pitch) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = glm::<span class="built_in">vec3</span>(posX, posY, posZ);</span><br><span class="line">        WorldUp = glm::<span class="built_in">vec3</span>(upX, upY, upZ);</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回使用欧拉角的观察矩阵</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(Position, Position + Front, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessKeyboard</span><span class="params">(Camera_Movement direction, <span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> velocity = MovementSpeed * deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (direction == FORWARD)</span><br><span class="line">            Position += Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == BACKWARD)</span><br><span class="line">            Position -= Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == LEFT)</span><br><span class="line">            Position -= Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == RIGHT)</span><br><span class="line">            Position += Right * velocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="type">float</span> xoffset, <span class="type">float</span> yoffset, GLboolean constrainPitch = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        xoffset *= MouseSensitivity;</span><br><span class="line">        yoffset *= MouseSensitivity;</span><br><span class="line"></span><br><span class="line">        Yaw += xoffset;</span><br><span class="line">        Pitch += yoffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制</span></span><br><span class="line">        <span class="keyword">if</span> (constrainPitch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">89.0f</span>;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">-89.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用更新的Euler角度更新“前向量”、“右向量”和“上向量”</span></span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标滚轮回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="type">float</span> yoffset)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Zoom -= (<span class="type">float</span>)yoffset;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &lt; <span class="number">1.0f</span>)</span><br><span class="line">            Zoom = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Zoom &gt; <span class="number">100.0f</span>)</span><br><span class="line">            Zoom = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 根据摄影机的（更新的）欧拉角计算前向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        <span class="comment">// 同时重新计算向右和向上矢量</span></span><br><span class="line">        <span class="comment">// 对向量进行归一化，因为向上或向下看得越多，它们的长度就越接近0，这会导致移动速度变慢</span></span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="6-扩展阅读"><a href="#6-扩展阅读" class="headerlink" title="6. 扩展阅读"></a>6. 扩展阅读</h1><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1568568/how-to-convert-euler-angles-to-directional-vector">如何将欧拉角转换为方向向量</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/433208062/answer/2428534603">欧拉角导致万向锁原因</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57585228/article/details/126534768">欧拉角与万向死锁</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/26/graphic/opengl/%E5%9D%90%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/graphic/opengl/%E5%9D%90%E6%A0%87/" class="post-title-link" itemprop="url">坐标</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 21:53:31 / 修改时间：22:20:18" itemprop="dateCreated datePublished" datetime="2023-07-26T21:53:31+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>对物体的不同操作有不同的意义，你如：当需要对物体进行修改的时候，在局部空间中操作会比较合理；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中更合理，等等。因此也衍生出了不同的坐标空间。</p>
<p><br></p>
<h1 id="2-坐标空间"><a href="#2-坐标空间" class="headerlink" title="2. 坐标空间"></a>2. 坐标空间</h1><ol>
<li>局部空间</li>
</ol>
<p>物体所在的坐标空间，即对象最开始所在的地方。建模软件中创建了一个立方体，立方体的原点有可能位于(0, 0, 0)，有可能创建的所有模型都以(0, 0, 0)为初始位置，然而它们会最终出现在世界的不同位置。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。</p>
<ol>
<li>世界空间</li>
</ol>
<p>指顶点相对于游戏世界的坐标。如果希望将物体分散在世界上摆放，就需要将物体变换到世界空间。该变换是由模型矩阵(Model Matrix)实现的。模型矩阵能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。经过模型矩阵变换后，物体的坐标将会从局部变换到世界空间。</p>
<ol>
<li>观察空间</li>
</ol>
<p>以摄像机为视角观察到的空间，因此也称摄像机空间。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果，因此观察空间就是从摄像机的视角所观察到的空间。改变换由观察矩阵(View Matrix)实现。</p>
<ol>
<li>裁剪空间</li>
</ol>
<p>OpenGL希望所有的坐标都在一个特定的范围内，所有不在范围内的顶点都会被裁剪丢弃，剩下才会进行处理，节省不必要的消耗。将顶点从观察空间变换到裁剪空间需要使用投影矩阵。指定了一个坐标范围，如：-100到100，投影矩阵会将该指定范围转换为标准化设备的范围(-1.0, 1.0)。所有在(-1.0, 1.0)之外的顶点都会被裁剪，比如顶点坐标为(80, 101)会被裁剪，因为转换后y坐标超出了范围，应该丢弃。</p>
<pre>
如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让它能够适合这个裁剪范围。
</pre>

<p>由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程被称之为投影(Projection)。</p>
<p>当所有顶点被变换到裁剪空间，会执行透视除法，在这个过程中做的就是将位置向量的x，y，z分量分别除以向量的齐次w分量；目的是把4D裁剪空间的齐次坐标变换为3D标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。</p>
<p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（即glViewport中的设定），并被变换成片段。投影矩阵有两种：</p>
<ul>
<li><p>正交投影</p>
</li>
<li><p><img src="坐标_1.jpg" alt="图2.1"></p>
</li>
</ul>
<p>正交投影定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。</p>
<p>由于每个向量的w分量都没有进行改变（w分量等于1.0），因此透视除法后坐标不变，出现的视觉效果是，进出的物体和远处的物体大小一致，造成不真实感。</p>
<p>GLM创建正交投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部</span></span><br><span class="line"><span class="comment">// 通过这四个参数定义近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离</span></span><br><span class="line"><span class="comment">// 这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标</span></span><br><span class="line">glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>透视投影</p>
</li>
<li><p><img src="坐标_2.jpg" alt="图2.2"></p>
</li>
</ul>
<p>现实生活中近大远小的现象称为透视，要实现透视效果需要使用透视投影矩阵来完成。透视投影矩阵将给定的平截头体范围映射到裁剪空间，还会修改每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何不在这个范围的坐标都会被裁剪掉）。OpenGL对在范围内的顶点进行透视除法操作：</p>
<p>$out=\begin{pmatrix} x/w \\ y/w \\ z/w \end{pmatrix}$</p>
<p>由于越远的物体w分量越大，因此模拟除了透视效果，这是w重要用途之一。</p>
<p>GLM创建透视投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数定义了fov的值，表示的是视野(Field of View)，想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值</span></span><br><span class="line"><span class="comment">// 第二个参数设置了宽高比，由视口的宽除以高所得</span></span><br><span class="line"><span class="comment">// 第三和第四个参数设置了平截头体的近和远平面。通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染</span></span><br><span class="line">glm::mat4 proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>
<pre>
当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致在游戏中的视觉效果：太过靠近一个物体的时候你的视线会直接穿过去。
</pre>

<p>由于正交投影没有使用透视，远处的物体不会显得更小，所以正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中更希望顶点不会被透视所干扰。</p>
<ol>
<li>屏幕空间</li>
</ol>
<p>顶点着色器的输出要求所有的顶点都在裁剪空间内，因此先将顶点从局部空间转换到裁剪空间：</p>
<p>$V_{clip}=M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}$</p>
<p>转换到裁剪空间后，最后会将结果赋值给顶点着色器的gl_Position，OpenGL将会自动进行透视除法和裁剪操作。</p>
<p>OpenGL接着会对裁剪坐标执行透视除法将它们变换到标准化设备坐标。OpenGL使用glViewPort内部的参数将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点，这个过程称为视口变换。</p>
<p><br></p>
<p>物体变换过程：</p>
<ul>
<li><img src="坐标_3.jpg" alt="图2.3"></li>
</ul>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，是物体起始的坐标</li>
<li>将局部坐标变换为世界空间坐标，这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放</li>
<li>将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的</li>
<li>坐标到达观察空间之后，需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上</li>
<li>最后将裁剪坐标变换为屏幕坐标，这是视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</li>
</ol>
<p><br></p>
<h1 id="3-实现3D效果"><a href="#3-实现3D效果" class="headerlink" title="3. 实现3D效果"></a>3. 实现3D效果</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模型矩阵</span></span><br><span class="line"><span class="comment">// 绕x轴旋转-55度</span></span><br><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建观察矩阵</span></span><br><span class="line"><span class="comment">// 往z轴正方向平移3个单位</span></span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建透视投影矩阵</span></span><br><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将矩阵传递到顶点着色器中</span></span><br><span class="line"><span class="type">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> viewLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;view&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(viewLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> projectionLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(projectionLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projection));</span><br></pre></td></tr></table></figure>
<p>顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将顶点变换到裁剪空间中，矩阵乘法要从右向左</span></span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="坐标_4.jpg" alt="图3.1"></li>
</ul>
<p><br></p>
<ol>
<li>3D立方体</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 36个顶点数据，包含顶点坐标和纹理</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改模型矩阵，让立方体随时间旋转</span></span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启深度缓冲</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次渲染迭代之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="坐标_5.gif" alt="图4.1"></li>
</ul>
<p><br></p>
<h1 id="5-更多立方体"><a href="#5-更多立方体" class="headerlink" title="5. 更多立方体"></a>5. 更多立方体</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个立方体的位置</span></span><br><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 赋予不同的模型矩阵</span></span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">    model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><img src="坐标_6.jpg" alt="图4.1"></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/25/graphic/opengl/%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/25/graphic/opengl/%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">变换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-25 21:32:02" itemprop="dateCreated datePublished" datetime="2023-07-25T21:32:02+08:00">2023-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-26 21:52:25" itemprop="dateModified" datetime="2023-07-26T21:52:25+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-向量"><a href="#1-向量" class="headerlink" title="1. 向量"></a>1. 向量</h1><p>既有大小又有方向的量，称为向量。向量相等的依据：方向相同且大小相等，如下图起点不同的两个向量 $\vec{v}$ 和 $\vec{w}$ 是相等的：</p>
<ul>
<li><img src="变换_1.jpg" alt="图1.1"></li>
</ul>
<p>向量数学表示：$\vec{v}=\begin{pmatrix} x \\ y \\ z \end{pmatrix}$</p>
<p><br></p>
<h1 id="2-向量运算"><a href="#2-向量运算" class="headerlink" title="2. 向量运算"></a>2. 向量运算</h1><h2 id="2-1-向量与标量"><a href="#2-1-向量与标量" class="headerlink" title="2.1 向量与标量"></a>2.1 向量与标量</h2><p>$\begin{pmatrix} x \\ y \\ z \end{pmatrix} + 1 = \begin{pmatrix} x+1 \\ y+1 \\ z+1 \end{pmatrix}$</p>
<h2 id="2-2-向量取反"><a href="#2-2-向量取反" class="headerlink" title="2.2 向量取反"></a>2.2 向量取反</h2><p>$-\vec{v}=-\begin{pmatrix} x \\ y \\ z \end{pmatrix}=\begin{pmatrix} -x \\ -y \\ -z \end{pmatrix}$</p>
<h2 id="2-3-向量加减"><a href="#2-3-向量加减" class="headerlink" title="2.3 向量加减"></a>2.3 向量加减</h2><p>$\vec{v}+\vec{w}=\begin{pmatrix} 1 \\ 2 \\ 3 \end{pmatrix}+\begin{pmatrix} 4 \\ 5 \\ 6 \end{pmatrix}=\begin{pmatrix} 5 \\ 7 \\ 9 \end{pmatrix}$</p>
<ul>
<li><img src="变换_2.jpg" alt="图2.3.1"></li>
</ul>
<p>$\vec{v}-\vec{w}=\begin{pmatrix} 1 \\ 2 \\ 3 \end{pmatrix}-\begin{pmatrix} 4 \\ 5 \\ 6 \end{pmatrix}=\begin{pmatrix} -3 \\ -3 \\ -3 \end{pmatrix}$</p>
<ul>
<li><img src="变换_3.jpg" alt="图2.3.2"></li>
</ul>
<h2 id="2-4-向量长度和单位向量"><a href="#2-4-向量长度和单位向量" class="headerlink" title="2.4 向量长度和单位向量"></a>2.4 向量长度和单位向量</h2><p>向量长度：$||\vec{v}||=\sqrt{x^2+y^2}$</p>
<p>单位向量：$\widehat{n} = \frac{\vec{v}}{||\vec{v}||}$</p>
<ul>
<li><img src="变换_4.jpg" alt="图2.3.3"></li>
</ul>
<h2 id="2-4-向量相乘"><a href="#2-4-向量相乘" class="headerlink" title="2.4 向量相乘"></a>2.4 向量相乘</h2><ol>
<li>点乘</li>
</ol>
<p>$\vec{v} \cdot \vec{w} = ||\vec{v}|| \cdot ||\vec{w}|| \cdot \cos\vartheta$</p>
<p>两个单位向量的点乘结果为两个向量的夹角：$\vec{v} \cdot \vec{w} = 1 \cdot 1 \cdot \cos\vartheta = \cos\vartheta$</p>
<p>几何意义：判断两个向量方向的相似性，即两个向量是否垂直、平行、方向相反等。</p>
<p>点乘计算：$\begin{pmatrix} 1 \\ -1 \\ 0 \end{pmatrix} \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} = (0.6 * 0) + (-1 * 1) + (0 * 0) = -1$，反余弦可得两向量夹角180度，方向相反。</p>
<ol>
<li>叉乘</li>
</ol>
<p>叉乘会生成一个垂直于两个向量的新向量，叉乘可以用来判断两个向量的位置关系，即一个向量是在另一个向量的右边还是左边。</p>
<p>叉乘计算：$\begin{pmatrix} A_x \\ A_y \\ A_z \end{pmatrix} \cdot \begin{pmatrix} B_x \\ B_y \\ B_z \end{pmatrix} = \begin{pmatrix} A_y \cdot B_z-A_z \cdot B_y \\ A_z \cdot B_x-A_x \cdot B_z \\ A_x \cdot B_y-A_y \cdot B_x \end{pmatrix}$</p>
<p><br></p>
<h1 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h1><p>矩阵就是一个矩形的数字、符号或表达式数组，矩阵中每一项叫做矩阵的元素。</p>
<h2 id="3-1-矩阵相乘"><a href="#3-1-矩阵相乘" class="headerlink" title="3.1 矩阵相乘"></a>3.1 矩阵相乘</h2><p>条件：</p>
<ol>
<li>左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘</li>
<li>矩阵相乘不遵守交换律，$A \cdot B \not= B \cdot A$</li>
</ol>
<p>例：</p>
<p>$\left[\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \end{matrix}\right] \cdot \left[\begin{matrix} 5 &amp; 6 \\ 7 &amp; 8 \\ \end{matrix}\right]=\left[\begin{matrix} 1 \cdot 5+2 \cdot 7 &amp; 1 \cdot 6+2 \cdot 8 \\ 3 \cdot 5+4 \cdot 7 &amp; 3 \cdot 6+4 \cdot 8 \\ \end{matrix}\right]=\left[\begin{matrix} 19 &amp; 22 \\ 43 &amp; 50 \\ \end{matrix}\right]$</p>
<h2 id="3-2-矩阵乘以向量"><a href="#3-2-矩阵乘以向量" class="headerlink" title="3.2 矩阵乘以向量"></a>3.2 矩阵乘以向量</h2><p>矩阵可以用来变换向量：</p>
<ol>
<li>缩放</li>
</ol>
<p>$\left[\begin{matrix} S_1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; S_2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; S_3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right] \cdot \left(\begin{matrix} x \\ y \\ z \\ w \\ \end{matrix}\right)=\left(\begin{matrix} S_1 \cdot x \\ S_2 \cdot y \\ S_3 \cdot z \\ w \\ \end{matrix}\right)$</p>
<ul>
<li><img src="变换_5.jpg" alt="图3.2.1"></li>
</ul>
<ol>
<li>平移</li>
</ol>
<p>$\left[\begin{matrix} 1 &amp; 0 &amp; 0 &amp; T_x \\ 0 &amp; 1 &amp; 0 &amp; T_y \\ 0 &amp; 0 &amp; 1 &amp; T_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right] \cdot \left(\begin{matrix} x \\ y \\ z \\ 1 \\ \end{matrix}\right)=\left(\begin{matrix} x+T_x \\ y+T_y \\ z+T_z \\ 1 \\ \end{matrix}\right)$</p>
<pre>
向量的w分量也叫齐次坐标，可以把x、y和z坐标分别除以w坐标从而将其次坐标转换为3D向量。如果w分类为1，则表示的是坐标，如果w分量为0，则表示的是向量。

其次坐标的一个主要用途是将平移操作由仿射变换转换为线性变换。
</pre>

<ol>
<li>旋转</li>
</ol>
<p>绕x轴：$\left[\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \cos\vartheta &amp; -\sin\vartheta &amp; 0 \\ 0 &amp; \sin\vartheta &amp; \cos\vartheta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p>
<p>绕y轴：$\left[\begin{matrix} \cos\vartheta &amp; 0 &amp; \sin\vartheta &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -\sin\vartheta &amp; 0 &amp; \cos\vartheta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p>
<p>绕z轴：$\left[\begin{matrix} \cos\vartheta &amp; -\sin\vartheta &amp; 0 &amp; 0 \\ \sin\vartheta &amp; \cos\vartheta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p>
<h2 id="3-3-矩阵组合"><a href="#3-3-矩阵组合" class="headerlink" title="3.3 矩阵组合"></a>3.3 矩阵组合</h2><p>将多个矩阵相乘可以将多个变换组合到一个矩阵中，比如先缩放再平移：$M=Trans \cdot Scale -&gt; Trans \cdot Scale \cdot \vec{v}=M \cdot \vec{v}$，矩阵相乘时，最右边的矩阵会先和向量相乘，所以这边表示的操作是先缩放后平移。</p>
<p><br></p>
<h1 id="4-GLM"><a href="#4-GLM" class="headerlink" title="4. GLM"></a>4. GLM</h1><p>GLM是OpenGL Mathematics的缩写，这是一个OpenGL数学库，点击<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">链接</a>进行下载，然后把头文件的根目录复制到includes文件夹就可以使用了，这里用的是低于0.99版本的GLM。</p>
<p>使用GLM库进行平移操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个向量</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 创建一个平移矩阵，平移(1, 1, 0)个单位</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="comment">// 平移操作</span></span><br><span class="line">vec = trans * vec;</span><br></pre></td></tr></table></figure>
<p>将变换应用到图形中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个矩阵</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line"><span class="comment">// 绕z轴逆时针旋转90度，glm::radians将角度转化为弧度</span></span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line"><span class="comment">// 缩放0.5倍</span></span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把矩阵传递给顶点着色器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="comment">// GLM的默认布局就是列主序，所以并不需要转置矩阵</span></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br></pre></td></tr></table></figure>
<p>顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵</span></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 变换操作</span></span><br><span class="line">    gl_Position = transform * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<ul>
<li><img src="变换_6.jpg" alt="图4.1"></li>
</ul>
<p>让矩形随着时间进行旋转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>
<p>矩阵的乘法是从右往左的，因此这里会先绕(0, 0, 1)旋转，然后再平移到屏幕右下角，虽然在逻辑上是先平移后旋转。</p>
<p>运行程序：</p>
<ul>
<li><img src="变换_7.gif" alt="图4.2"><br><br></li>
</ul>
<h1 id="5-扩展阅读"><a href="#5-扩展阅读" class="headerlink" title="5. 扩展阅读"></a>5. 扩展阅读</h1><p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">线性代数本质</a>：<a target="_blank" rel="noopener" href="https://space.bilibili.com/88461692#!/channel/detail?cid=9450">中文字幕版本</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/21/graphic/opengl/%E7%BA%B9%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/21/graphic/opengl/%E7%BA%B9%E7%90%86/" class="post-title-link" itemprop="url">纹理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-21 20:56:56 / 修改时间：21:20:03" itemprop="dateCreated datePublished" datetime="2023-07-21T20:56:56+08:00">2023-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-纹理的作用"><a href="#1-纹理的作用" class="headerlink" title="1. 纹理的作用"></a>1. 纹理的作用</h1><p>通过给顶点输入颜色数据可以让顶点显示指定的颜色，如果想渲染出更真实的图形，那么就需要足够多的顶点数据和颜色数据才能实现，这样开销很大。使用纹理可以解决这个问题。</p>
<p>纹理通常是一张2D图片（也有1D和3D的），是存储物体细节的容器，可以将物体需要的细节数据存储在纹理中，渲染的时候从纹理中采样出所需要的数据，这样就可以让物体非常的同时也不用添加大量的顶点数据。相当于把纹理贴到物体表面，这样物体就有了该纹理的外观，如下图：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_1.jpg" alt="图1.1"></li>
</ul>
<p>想要把纹理映射到三角形上，需要指定每个三角形的每个顶点对应纹理的哪个部分，让每个顶点和纹理坐标关联起来，表示每个顶点该从纹理的哪个部分采样。纹理坐标的范围在0到1之间，使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，终始于(1, 1)，下图展示了怎样将纹理映射到三角形：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_2.jpg" alt="图1.2"></li>
</ul>
<p>纹理映射只要给顶点着色器传递纹理坐标就行，它们会被传片段着色器中，片段着色器中会为每个片段进行纹理坐标的插值。</p>
<br>

<h1 id="2-环绕方式"><a href="#2-环绕方式" class="headerlink" title="2. 环绕方式"></a>2. 环绕方式</h1><p>纹理坐标范围从(0, 0)到(1, 1)，假设把纹理坐标设置在这个范围之外，应该如何表现？OpenGL提供了以下表现形式：</p>
<ul>
<li>GL_REPEAT: 重复纹理图像</li>
<li>GL_MIRRORED_REPEAT: 镜像重复</li>
<li>GL_CLAMP_TO_EDGE: 超出的部分会重复纹理坐标的边缘，产生边缘被拉伸的效果</li>
<li>GL_CLAMP_TO_BORDER: 超出的坐标为自定义的边缘颜色</li>
</ul>
<p>视觉效果如下图：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_3.jpg" alt="图2.1"></li>
</ul>
<p>设置代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置s(x)轴超出镜像重复</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">// 设置t(y)轴超出镜像重复</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">// 指定颜色</span></span><br><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3. 过滤"></a>3. 过滤</h1><p>纹理是由纹理像素组成，而采样的时候使用的是纹理坐标，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标。有了映射方法才能够根据纹理坐标去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色，最终显示。这里会有一些问题：</p>
<ol>
<li>纹理分辨率很小：图像上的多个像素在渲染时取纹理映射上取到了同一个点，会有明显的方块状</li>
<li>纹理分辨率过大：图像上的一个像素覆盖的多个纹素，远处出现摩尔纹，进出出现锯齿</li>
</ol>
<p>因此，需要一些过滤方法进行处理，纹理过滤最重要的两种：</p>
<ol>
<li>GL_NEAREST</li>
</ol>
<p>邻近过滤，OpenGL的默认过滤方式，当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素，如下图：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_4.jpg" alt="图3.1"></li>
</ul>
<ol start="2">
<li>GL_LINEAR</li>
</ol>
<p>线性过滤，选取纹理坐标附近的n个纹理像素使用插值方法，进行颜色混合。一个纹理像素的中心距离纹理坐标越近对最终的样本颜色的贡献越大，如下图：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_5.jpg" alt="图3.2"></li>
</ul>
<p>两种方式的效果：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_6.jpg" alt="图3.3"></li>
</ul>
<p>线性过滤更够生成更加平滑的效果，通常在图片被放大后可以设置为线性过滤，而初始状态或者别缩小可以设置为邻近过滤节省性能，设置代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="4-Mipmap"><a href="#4-Mipmap" class="headerlink" title="4. Mipmap"></a>4. Mipmap</h1><p>在透视投影下，远处的物体会更小，如果这时候让它们使用和近处分辨率一样大的纹理，则不合适。由于远处的物体只产生很少的片段，而纹理分辨率太高，导致一个片段会跨越大范围纹理（即像素覆盖一片纹理区域）， 因此OpenGL很难对该片段只拾取一个纹理颜色，导致在小物体上这会产生不真实的感觉；同时高分辨率占用的内存也大，在远处物体上造成内存浪费。</p>
<p>OpenGL使用多级渐远纹理(Mipmap)解决该问题，Mipmap是一系列的纹理图像，后一个纹理图像是前一个的二分之一。思想：对不同距离的物体，使用不同的多级渐远纹理。同时，多级渐远纹理的性能也很好，Mipmap占用内存只是原始纹理的1.33倍，Mipmap如下：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_7.jpg" alt="图4.1"></li>
</ul>
<p>OpenGL创建Mipmap：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="comment">// 不要将放大的操作设置为Mipmap的过滤选项，这回产生异常，因为纹理放大不会使用Mipmap</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="5-纹理的加载与创建"><a href="#5-纹理的加载与创建" class="headerlink" title="5. 纹理的加载与创建"></a>5. 纹理的加载与创建</h1><h2 id="5-1-加载纹理"><a href="#5-1-加载纹理" class="headerlink" title="5.1 加载纹理"></a>5.1 加载纹理</h2><p><a target="_blank" rel="noopener" href="https://github.com/nothings">Sean Barrett</a>的一个非常流行的单头文件图像加载库，<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h">下载链接</a>。加载图片：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽高和颜色通道</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;image.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-创建纹理"><a href="#5-2-创建纹理" class="headerlink" title="5.2 创建纹理"></a>5.2 创建纹理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1个纹理</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用纹理数据生成纹理</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="comment">// 生成Mipmap</span></span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数据</span></span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure>

<h2 id="5-3-应用纹理"><a href="#5-3-应用纹理" class="headerlink" title="5.3 应用纹理"></a>5.3 应用纹理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顶点数据中添加纹理坐标用来告诉OpenGL如何对纹理进行采样</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新的顶点格式：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_8.jpg" alt="图5.3.1"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析纹理坐标并启用</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采样器</span></span><br><span class="line">uniform sampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用纹理坐标在采样器中采样纹理的颜色</span></span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绘制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_9.jpg" alt="图5.3.2"></li>
</ul>
<br>

<h1 id="6-纹理单元"><a href="#6-纹理单元" class="headerlink" title="6. 纹理单元"></a>6. 纹理单元</h1><p>个纹理的位置值通常称为一个纹理单元，纹理的默认纹理单元是0，它也是默认的激活纹理单元。有了纹理单元就可以在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器可以一次绑定多个纹理，然后激活对应的纹理单元，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在绑定纹理之前先激活纹理单元，纹理单元0默认被激活</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>

<p>修改片段着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据第三个参数进行线性插值</span></span><br><span class="line">    <span class="comment">// 如果第三个值是0.0，它会返回第一个输入</span></span><br><span class="line">    <span class="comment">// 如果是1.0，会返回第二个输入值</span></span><br><span class="line">    <span class="comment">// 0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色</span></span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用第二张纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改顶点</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">2.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">2.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转y轴</span></span><br><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入纹理图片...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定和激活</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置uniform变量之要先前激活着色器程序</span></span><br><span class="line">ourShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">// 设置采样器对应的纹理单元</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture2&quot;</span>), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<ul>
<li><img src="%E7%BA%B9%E7%90%86_10.jpg" alt="图6.1"></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/" class="post-title-link" itemprop="url">着色器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-18 21:20:44" itemprop="dateCreated datePublished" datetime="2023-07-18T21:20:44+08:00">2023-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-21 21:20:44" itemprop="dateModified" datetime="2023-07-21T21:20:44+08:00">2023-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-程序结构"><a href="#1-程序结构" class="headerlink" title="1. 程序结构"></a>1. 程序结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="2-输入与输出"><a href="#2-输入与输出" class="headerlink" title="2. 输入与输出"></a>2. 输入与输出</h1><p>着色器虽然都是独立的小程序，但是最后经过编译链接后都是一个整体的一部分，所以每个着色器都通过输入和输出进行数据交互。GLSL定义了in和out关键字专门来实现这个目的，遵循原则：<strong>输出变量与下一个着色器阶段的输入匹配（类型与变量名完全一致），就会传递下去。</strong></p>
<p>顶点着色器可以使用location指定输入变量，实现可以在CPU上配置顶点属性，从顶点数据中直接接收输入，如layout (location &#x3D; 0) in vec3 pos。</p>
<pre>
也可以忽略layout (location = 0)标识符，使用glGetAttribLocation查询属性位置值(Location)，在着色器中设置可以节省OpenGL的工作量。
</pre>

<br>

<ol>
<li>顶点着色器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>片段着色器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器需要输出最终像素颜色，如果没有定义输出颜色会显示黑或白，这里颜色通过顶点着色器发送。vertexColor在两个着色器中类型和变量名完全一致，因此在编译链接着色器程序的过程中，OpenGL会把两个变量链接在一起，使它们可以发送数据。</p>
<p>运行程序：</p>
<ul>
<li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_1.jpg" alt="图2.1"></li>
</ul>
<br>

<h1 id="3-Uniform"><a href="#3-Uniform" class="headerlink" title="3. Uniform"></a>3. Uniform</h1><p>特点：</p>
<ul>
<li>支持从CPU发送数据到GPU</li>
<li>变量是全局的，它可以被着色器程序的任意着色器在任意阶段访问</li>
<li>论你把uniform值设置成什么，uniform会一直保存它们的数据，直到被重置或更新</li>
<li>声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，最后编译出的版本中并不会包含它</li>
</ul>
<p>修改片段着色器代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CPU中传递颜色数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染</span></span><br><span class="line">    <span class="comment">// 清除颜色缓冲</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得激活着色器</span></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运行时间</span></span><br><span class="line">    <span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">    <span class="comment">// 颜色分量</span></span><br><span class="line">    <span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">// 查询uniform ourColor的位置值，返回-1代表没有找到这个位置值</span></span><br><span class="line">    <span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">    <span class="comment">// 激活着色器程序</span></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 设置颜色值，更新uniform值之前必须先激活着色器程序</span></span><br><span class="line">    <span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制三角形</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲并查询IO事件</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<ul>
<li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_2.gif" alt="图3.1"></li>
</ul>
<br>

<h1 id="4-链接更多属性"><a href="#4-链接更多属性" class="headerlink" title="4. 链接更多属性"></a>4. 链接更多属性</h1><p>把颜色添加到顶点数据中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调整顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line">out vec3 ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除片段着色器中的uniform变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;  </span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加了另一个顶点属性，并且更新了VBO的内存后，VBO内存中的数据布局：</p>
<ul>
<li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_3.jpg" alt="图4.1"></li>
</ul>
<p>解析顶点数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性，位置0</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性，位置1，起始偏移3 * sizeof(float)</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<ul>
<li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_4.jpg" alt="图4.2"></li>
</ul>
<br>

<h1 id="5-着色器类"><a href="#5-着色器类" class="headerlink" title="5. 着色器类"></a>5. 着色器类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="comment">// constructor generates the shader on the fly</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> <span class="type">char</span>* vertexPath, <span class="type">const</span> <span class="type">char</span>* fragmentPath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. retrieve the vertex/fragment source code from filePath</span></span><br><span class="line">        std::string vertexCode;</span><br><span class="line">        std::string fragmentCode;</span><br><span class="line">        std::ifstream vShaderFile;</span><br><span class="line">        std::ifstream fShaderFile;</span><br><span class="line">        <span class="comment">// ensure ifstream objects can throw exceptions:</span></span><br><span class="line">        vShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        fShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// open files</span></span><br><span class="line">            vShaderFile.<span class="built_in">open</span>(vertexPath);</span><br><span class="line">            fShaderFile.<span class="built_in">open</span>(fragmentPath);</span><br><span class="line">            std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">            <span class="comment">// read file&#x27;s buffer contents into streams</span></span><br><span class="line">            vShaderStream &lt;&lt; vShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            fShaderStream &lt;&lt; fShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            <span class="comment">// close file handlers</span></span><br><span class="line">            vShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            fShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            <span class="comment">// convert stream into string</span></span><br><span class="line">            vertexCode   = vShaderStream.<span class="built_in">str</span>();</span><br><span class="line">            fragmentCode = fShaderStream.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::ifstream::failure&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 2. compile shaders</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vertex, fragment;</span><br><span class="line">        <span class="comment">// vertex shader</span></span><br><span class="line">        vertex = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(vertex);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line">        <span class="comment">// fragment Shader</span></span><br><span class="line">        fragment = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(fragment, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(fragment);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line">        <span class="comment">// shader Program</span></span><br><span class="line">        ID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, vertex);</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, fragment);</span><br><span class="line">        <span class="built_in">glLinkProgram</span>(ID);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br><span class="line">        <span class="comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span></span><br><span class="line">        <span class="built_in">glDeleteShader</span>(vertex);</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// activate the shader</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUseProgram</span>(ID); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// utility uniform functions</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">bool</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;         </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), (<span class="type">int</span>)value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">float</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// utility function for checking shader compilation/linking errors.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkCompileErrors</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shader, std::string type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> success;</span><br><span class="line">        <span class="type">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="string">&quot;PROGRAM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetShaderInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetProgramInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;path/to/shaders/shader.vs&quot;</span>, <span class="string">&quot;path/to/shaders/shader.fs&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;someUniform&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://raoyuqi.github.io/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奇遇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 奇遇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/" class="post-title-link" itemprop="url">画三角形</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-17 20:46:20" itemprop="dateCreated datePublished" datetime="2023-07-17T20:46:20+08:00">2023-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-21 21:20:50" itemprop="dateModified" datetime="2023-07-21T21:20:50+08:00">2023-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-图形渲染管线"><a href="#1-图形渲染管线" class="headerlink" title="1. 图形渲染管线"></a>1. 图形渲染管线</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>图形渲染管线是个流水线，分为好几个阶段，主要的工作为：将3D空间中的坐标转换为屏幕空间的2D坐标，并最终把2D坐标转换为有颜色的像素，形成画面。</p>
<br>

<h2 id="1-2-着色器"><a href="#1-2-着色器" class="headerlink" title="1.2 着色器"></a>1.2 着色器</h2><p>图形渲染管线分为多个阶段，每个阶段会把前一个阶段的输出作为输入。每个阶段高度专门化，非常容易并行执行，因此大多数显卡都有成千上万个小处理核心，处理核心负责在GPU上为每个流水线阶段处运行各自的程序，达到在渲染管线中快速并行地处理数据，这些小程序就是着色器。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写的。</p>
<br>

<h2 id="1-3-阶段"><a href="#1-3-阶段" class="headerlink" title="1.3 阶段"></a>1.3 阶段</h2><p>如图，蓝色部分是可以自定义的部分：</p>
<ul>
<li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_1.jpg" alt="图形渲染管线"></li>
</ul>
<ol>
<li>顶点着色器</li>
</ol>
<p>以顶点坐标作为输入，将其处理成齐次坐标。</p>
<ol start="2">
<li>图元装配</li>
</ol>
<p>将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定的图元形状（点、三角形等）。</p>
<ol start="3">
<li>几何着色器</li>
</ol>
<p>把图元装配形成的顶点集合作为输入，这个阶段可以产生新顶点，构造出新的图元来生成其它形状。</p>
<ol start="4">
<li>光栅化阶段</li>
</ol>
<p>几何着色器的输出作为输入，这个阶段会把图元映射为最终屏幕上对应的像素，生成给片段着色器使用的片段。生成片段过程中会执行裁剪，丢弃超出视图以外的所有像素，提升下个阶段的效率。</p>
<ol start="5">
<li>片段着色器</li>
</ol>
<p>这里会计算出像素最后显示的颜色，是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色</p>
<ol start="6">
<li>Alpha测试和混合</li>
</ol>
<p>这是最后一个阶段，会对片段进行一系列检测，如深度和模板测试，透明度测试及混合等。</p>
<p><strong>现代OpenGL中，至少定义一个顶点着色器和片段着色器。</strong></p>
<br>

<h1 id="2-绘制三角形"><a href="#2-绘制三角形" class="headerlink" title="2. 绘制三角形"></a>2. 绘制三角形</h1><ol>
<li>准备顶点数据</li>
</ol>
<p>tip: OpenGL是3D图形库，因此指定的坐标需要是3D坐标；OpenGL只处理标准化设备坐标，即-1.0到1.0范围内的坐标，并不是简单地把3D坐标转换为屏幕上的2D像素。</p>
<p>给定如下输入坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个z坐标设为0，让它看上去是2D的</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre>
深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果被别的像素遮挡，

就看不到它了，将会被丢弃，以节省资源。
</pre>

<p>该组坐标在标准化设备中对应如下三角形：</p>
<ul>
<li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_2.jpg" alt="标准化设备中的三角形"></li>
</ul>
<p>接下来把顶点坐标传给渲染管线的第一个阶段（顶点着色器），顶点着色器会在GPU上创建内存，用来存储顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。</p>
<ol start="2">
<li>创建VBO</li>
</ol>
<p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被成为显存）中存储大量顶点。使用缓冲对象的好处是可以批量发送数据到显卡上，而不是每次发送一个顶点。从CPU把数据发送到显卡相对较慢，但是当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建VBO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到GL_ARRAY_BUFFER，绑定后使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<pre>
希望显卡如何管理给定的数据的三种形式：

- GL_STATIC_DRAW ：数据不会或几乎不会改变
- GL_DYNAMIC_DRAW：数据会被改变很多
- GL_STREAM_DRAW ：数据每次绘制时都会改变
</pre>

<p>这样顶点数据就被存储到显存中了，被VBO这个顶点缓冲对象所管理着。</p>
<br>

<ol start="3">
<li>着色器</li>
</ol>
<p>用GLSL编写顶点着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号和核心模式</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="comment">// 设定了输入变量的位置值</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 接收顶点数据</span></span><br><span class="line">in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ol start="4">
<li>编译着色器</li>
</ol>
<p>将第3步的着色器代码赋值给字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个顶点着色器对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器源码附加到着色器对象上</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<br>

<ol start="5">
<li>着色器程序</li>
</ol>
<p>着色器程序对象是多个着色器最终链接完成的版本。如果要使用刚才编译的着色器必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在发送渲染调用的时候被使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建着色器程序对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="comment">// 附加着色器对象到程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="comment">// 链接</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活着色器程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// 释放不再需要的资源</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>到这一步已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理这些数据。接下来需要告诉OpenGL如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。</p>
<br>

<ol start="6">
<li>链接顶点属性</li>
</ol>
<p>必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以必须在渲染前指定OpenGL该如何解释顶点数据，顶点缓冲数据会被解析为下面这样子：</p>
<ul>
<li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_3.jpg" alt="顶点缓冲数据"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 以顶点属性位置值作为参数，启用顶点属性，默认是禁用的</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<br>

<ol start="7">
<li>顶点数组对象VAO</li>
</ol>
<p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。好处是，当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了，因为设置的所有状态都将存储在VAO中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个VAO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure>

<p>当打算绘制多个物体时，首先要生成&#x2F;配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。这段代码应该看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 绘制物体</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br><span class="line"><span class="comment">// 解绑VAO</span></span><br></pre></td></tr></table></figure>

<br>

<ol start="8">
<li>绘制三角形</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活着色器程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 画三角形，顶点数组的起始索引为0，绘制3个顶点</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ul>
<li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_4.jpg" alt="三角形"></li>
</ul>
<br>

<h1 id="3-元素缓冲对象"><a href="#3-元素缓冲对象" class="headerlink" title="3. 元素缓冲对象"></a>3. 元素缓冲对象</h1><p>元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。假设不绘制一个三角形而是绘制一个矩形。可以绘制两个三角形来组成一个矩形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个矩形只有4个而不是6个顶点，这样会产生50%的额外开销，如果有包括上千个三角形的模型，这会产生一大堆浪费。可以通过<strong>只储存不同的顶点，并设定绘制这些顶点的顺序。</strong>这样子只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行。元素缓冲区对象就是用来做这个的。</p>
<p>EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储OpenGL用来决定要绘制哪些顶点的顺序。定义不重复的顶点和绘制出矩形所需的索引顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意索引从0开始! </span></span><br><span class="line"><span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line"><span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EBO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="comment">// 把索引复制到缓冲里</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引缓冲区渲染三角形</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ul>
<li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_5.jpg" alt="矩形"></li>
</ul>
<pre>
线框模式

glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。

第一个参数表示打算将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。

之后的绘制调用会一直以线框模式绘制三角形，直到调用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。
</pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
