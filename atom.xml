<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇遇的博客</title>
  
  
  <link href="https://raoyuqi.github.io/atom.xml" rel="self"/>
  
  <link href="https://raoyuqi.github.io/"/>
  <updated>2023-07-29T03:31:34.544Z</updated>
  <id>https://raoyuqi.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>摄像机</title>
    <link href="https://raoyuqi.github.io/2023/07/29/graphic/opengl/%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <id>https://raoyuqi.github.io/2023/07/29/graphic/opengl/%E6%91%84%E5%83%8F%E6%9C%BA/</id>
    <published>2023-07-29T02:12:24.000Z</published>
    <updated>2023-07-29T03:31:34.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-构建摄像机"><a href="#1-构建摄像机" class="headerlink" title="1. 构建摄像机"></a>1. 构建摄像机</h1><h2 id="1-1-确定位置"><a href="#1-1-确定位置" class="headerlink" title="1.1 确定位置"></a>1.1 确定位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure><h2 id="1-2-确定z轴"><a href="#1-2-确定z轴" class="headerlink" title="1.2 确定z轴"></a>1.2 确定z轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让摄像机指向场景原点</span></span><br><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// 向量相减，让相机的z轴正方向看向世界的z轴负方向</span></span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><h2 id="1-3-确定x轴"><a href="#1-3-确定x轴" class="headerlink" title="1.3 确定x轴"></a>1.3 确定x轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个上向量</span></span><br><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// y,z叉乘得到x轴正方向</span></span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br></pre></td></tr></table></figure><h2 id="1-4-确定y轴"><a href="#1-4-确定y轴" class="headerlink" title="1.4 确定y轴"></a>1.4 确定y轴</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z,x叉乘得到y轴正方向</span></span><br><span class="line">glm::vec3 cameraUp = glm::<span class="built_in">cross</span>(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><p>摄像机坐标系如图：</p><ul><li><img src="摄像机_1.jpg" alt="图1.4.1"></li></ul><p><br></p><h1 id="2-GLM构建观察空间矩阵"><a href="#2-GLM构建观察空间矩阵" class="headerlink" title="2. GLM构建观察空间矩阵"></a>2. GLM构建观察空间矩阵</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 传入摄像机位置，目标方向，和向上向量构建观察矩阵</span></span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>实现相机绕原点旋转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 半径</span></span><br><span class="line"><span class="type">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="comment">// 画圆</span></span><br><span class="line"><span class="type">float</span> camX = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line"><span class="type">float</span> camZ = <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="摄像机_2.gif" alt="图2.1"></li></ul><p><br></p><h1 id="3-自由移动"><a href="#3-自由移动" class="headerlink" title="3. 自由移动"></a>3. 自由移动</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>); <span class="comment">// 看向z轴负方向</span></span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察矩阵始终看向z轴负方向</span></span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, cameraPos + cameraFront, cameraUp);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听键盘输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">0.05f</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed; <span class="comment">// 减去叉乘得到x轴正方向，往左移动, normalize保证匀速</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed; <span class="comment">// 加上叉乘得到x轴正方向，往右移动, normalize保证匀速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整移动速度：</p><p>根据处理器的能力不同，不能保证不同设备每秒绘制相同帧数。导致配置的不同，有些人可能移动很快，而有些人会移动很慢。实现不同设备匀速：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="type">float</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 上一帧的时间</span></span><br><span class="line"><span class="type">float</span> lastFrame = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="comment">// 更新渲染当前帧花费的时间</span></span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用时间去平衡速度：帧率高的deltaTime小，速度慢，帧率低的deltaTime大，速度快</span></span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="摄像机_3.gif" alt="图3.1"></li></ul><p><br></p><h1 id="4-视角移动"><a href="#4-视角移动" class="headerlink" title="4. 视角移动"></a>4. 视角移动</h1><h2 id="4-1-欧拉角"><a href="#4-1-欧拉角" class="headerlink" title="4.1 欧拉角"></a>4.1 欧拉角</h2><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，如下图：</p><ul><li><img src="摄像机_4.jpg" alt="图4.1"></li></ul><p>游戏中的摄像机比较少使用到滚转角，此处推导经过俯仰角和偏航角后摄像机的方向：</p><ul><li><img src="摄像机_5.jpg" alt="图4.2"></li></ul><p>可得：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由相机初始看向x正半轴推导出来的相机新的方向</span></span><br><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br></pre></td></tr></table></figure><p>可以用用旋转矩阵进行推导，出现结果不一致可参考<a href="https://math.stackexchange.com/questions/1791209/euler-angle-to-direction-vector-which-is-right">链接</a>。</p><h2 id="4-2-鼠标输入"><a href="#4-2-鼠标输入" class="headerlink" title="4.2 鼠标输入"></a>4.2 鼠标输入</h2><p>通过鼠标的移动来控制镜头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上一次鼠标位置</span></span><br><span class="line"><span class="type">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏光标</span></span><br><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听鼠标输入</span></span><br><span class="line"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 防止首次抖动</span></span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算x,y偏移</span></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灵敏度</span></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    <span class="comment">// 偏移乘上灵敏系数，获得合适的改变幅度</span></span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将偏移加到仰俯，偏航角上</span></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制极限情况(在90度时视角会发生逆转)</span></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用公式计算新的相机方向</span></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-缩放"><a href="#4-3-缩放" class="headerlink" title="4.3 缩放"></a>4.3 缩放</h2><p>缩放的原理是改变fov视野大小，当视野变小时，场景投影出来的空间就会减小，产生放大的感觉，视野变大则相反，代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 监听鼠标滚轮输入</span></span></span><br><span class="line"><span class="function"><span class="title">glfwSetScrollCallback</span><span class="params">(window, scroll_callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov -= yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新投影矩阵的视野</span></span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="摄像机_6.gif" alt="图4.3"></li></ul><p><br></p><h1 id="5-摄像机类"><a href="#5-摄像机类" class="headerlink" title="5. 摄像机类"></a>5. 摄像机类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/detail/type_vec.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机移动方向</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Camera_Movement</span> &#123;</span><br><span class="line">    FORWARD,</span><br><span class="line">    BACKWARD,</span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认偏航角</span></span><br><span class="line"><span class="comment">// 由于公式用的初态相机位置看向x轴正方向，因此偏航-90度，让相机看向z轴负方向</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> YAW = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="comment">// 默仰俯角</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PITCH = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 默认移动速度</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SPEED = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">// 默认鼠标灵敏系数，影响旋转</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SENSITIVITY = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">// 默认缩放视野</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> ZOOM = <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 位置</span></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    <span class="comment">// 向前方向 z轴</span></span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    <span class="comment">// 向上方向 y轴</span></span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    <span class="comment">// 向右方向 x轴</span></span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    <span class="comment">// 世界的上方向</span></span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧拉角</span></span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它属性</span></span><br><span class="line">    <span class="type">float</span> MovementSpeed;</span><br><span class="line">    <span class="type">float</span> MouseSensitivity;</span><br><span class="line">    <span class="type">double</span> Zoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Camera</span>(glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), <span class="type">float</span> yaw = YAW, <span class="type">float</span> pitch = PITCH) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = position;</span><br><span class="line">        WorldUp = up;</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="type">float</span> posX, <span class="type">float</span> posY, <span class="type">float</span> posZ, <span class="type">float</span> upX, <span class="type">float</span> upY, <span class="type">float</span> upZ, <span class="type">float</span> yaw, <span class="type">float</span> pitch) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = glm::<span class="built_in">vec3</span>(posX, posY, posZ);</span><br><span class="line">        WorldUp = glm::<span class="built_in">vec3</span>(upX, upY, upZ);</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回使用欧拉角的观察矩阵</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(Position, Position + Front, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessKeyboard</span><span class="params">(Camera_Movement direction, <span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> velocity = MovementSpeed * deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (direction == FORWARD)</span><br><span class="line">            Position += Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == BACKWARD)</span><br><span class="line">            Position -= Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == LEFT)</span><br><span class="line">            Position -= Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == RIGHT)</span><br><span class="line">            Position += Right * velocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="type">float</span> xoffset, <span class="type">float</span> yoffset, GLboolean constrainPitch = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        xoffset *= MouseSensitivity;</span><br><span class="line">        yoffset *= MouseSensitivity;</span><br><span class="line"></span><br><span class="line">        Yaw += xoffset;</span><br><span class="line">        Pitch += yoffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制</span></span><br><span class="line">        <span class="keyword">if</span> (constrainPitch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">89.0f</span>;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">-89.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用更新的Euler角度更新“前向量”、“右向量”和“上向量”</span></span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标滚轮回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="type">float</span> yoffset)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Zoom -= (<span class="type">float</span>)yoffset;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &lt; <span class="number">1.0f</span>)</span><br><span class="line">            Zoom = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Zoom &gt; <span class="number">100.0f</span>)</span><br><span class="line">            Zoom = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 根据摄影机的（更新的）欧拉角计算前向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        <span class="comment">// 同时重新计算向右和向上矢量</span></span><br><span class="line">        <span class="comment">// 对向量进行归一化，因为向上或向下看得越多，它们的长度就越接近0，这会导致移动速度变慢</span></span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><br></p><h1 id="6-扩展阅读"><a href="#6-扩展阅读" class="headerlink" title="6. 扩展阅读"></a>6. 扩展阅读</h1><p><a href="https://stackoverflow.com/questions/1568568/how-to-convert-euler-angles-to-directional-vector">如何将欧拉角转换为方向向量</a></p><p><a href="https://www.zhihu.com/question/433208062/answer/2428534603">欧拉角导致万向锁原因</a></p><p><a href="https://blog.csdn.net/m0_57585228/article/details/126534768">欧拉角与万向死锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-构建摄像机&quot;&gt;&lt;a href=&quot;#1-构建摄像机&quot; class=&quot;headerlink&quot; title=&quot;1. 构建摄像机&quot;&gt;&lt;/a&gt;1. 构建摄像机&lt;/h1&gt;&lt;h2 id=&quot;1-1-确定位置&quot;&gt;&lt;a href=&quot;#1-1-确定位置&quot; class=&quot;header</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>坐标</title>
    <link href="https://raoyuqi.github.io/2023/07/26/graphic/opengl/%E5%9D%90%E6%A0%87/"/>
    <id>https://raoyuqi.github.io/2023/07/26/graphic/opengl/%E5%9D%90%E6%A0%87/</id>
    <published>2023-07-26T13:53:31.000Z</published>
    <updated>2023-07-26T14:20:18.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>对物体的不同操作有不同的意义，你如：当需要对物体进行修改的时候，在局部空间中操作会比较合理；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中更合理，等等。因此也衍生出了不同的坐标空间。</p><p><br></p><h1 id="2-坐标空间"><a href="#2-坐标空间" class="headerlink" title="2. 坐标空间"></a>2. 坐标空间</h1><ol><li>局部空间</li></ol><p>物体所在的坐标空间，即对象最开始所在的地方。建模软件中创建了一个立方体，立方体的原点有可能位于(0, 0, 0)，有可能创建的所有模型都以(0, 0, 0)为初始位置，然而它们会最终出现在世界的不同位置。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。</p><ol><li>世界空间</li></ol><p>指顶点相对于游戏世界的坐标。如果希望将物体分散在世界上摆放，就需要将物体变换到世界空间。该变换是由模型矩阵(Model Matrix)实现的。模型矩阵能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。经过模型矩阵变换后，物体的坐标将会从局部变换到世界空间。</p><ol><li>观察空间</li></ol><p>以摄像机为视角观察到的空间，因此也称摄像机空间。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果，因此观察空间就是从摄像机的视角所观察到的空间。改变换由观察矩阵(View Matrix)实现。</p><ol><li>裁剪空间</li></ol><p>OpenGL希望所有的坐标都在一个特定的范围内，所有不在范围内的顶点都会被裁剪丢弃，剩下才会进行处理，节省不必要的消耗。将顶点从观察空间变换到裁剪空间需要使用投影矩阵。指定了一个坐标范围，如：-100到100，投影矩阵会将该指定范围转换为标准化设备的范围(-1.0, 1.0)。所有在(-1.0, 1.0)之外的顶点都会被裁剪，比如顶点坐标为(80, 101)会被裁剪，因为转换后y坐标超出了范围，应该丢弃。</p><pre>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让它能够适合这个裁剪范围。</pre><p>由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程被称之为投影(Projection)。</p><p>当所有顶点被变换到裁剪空间，会执行透视除法，在这个过程中做的就是将位置向量的x，y，z分量分别除以向量的齐次w分量；目的是把4D裁剪空间的齐次坐标变换为3D标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（即glViewport中的设定），并被变换成片段。投影矩阵有两种：</p><ul><li><p>正交投影</p></li><li><p><img src="坐标_1.jpg" alt="图2.1"></p></li></ul><p>正交投影定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。</p><p>由于每个向量的w分量都没有进行改变（w分量等于1.0），因此透视除法后坐标不变，出现的视觉效果是，进出的物体和远处的物体大小一致，造成不真实感。</p><p>GLM创建正交投影矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部</span></span><br><span class="line"><span class="comment">// 通过这四个参数定义近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离</span></span><br><span class="line"><span class="comment">// 这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标</span></span><br><span class="line">glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><ul><li><p>透视投影</p></li><li><p><img src="坐标_2.jpg" alt="图2.2"></p></li></ul><p>现实生活中近大远小的现象称为透视，要实现透视效果需要使用透视投影矩阵来完成。透视投影矩阵将给定的平截头体范围映射到裁剪空间，还会修改每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何不在这个范围的坐标都会被裁剪掉）。OpenGL对在范围内的顶点进行透视除法操作：</p><p>$out=\begin{pmatrix} x/w \\ y/w \\ z/w \end{pmatrix}$</p><p>由于越远的物体w分量越大，因此模拟除了透视效果，这是w重要用途之一。</p><p>GLM创建透视投影矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数定义了fov的值，表示的是视野(Field of View)，想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值</span></span><br><span class="line"><span class="comment">// 第二个参数设置了宽高比，由视口的宽除以高所得</span></span><br><span class="line"><span class="comment">// 第三和第四个参数设置了平截头体的近和远平面。通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染</span></span><br><span class="line">glm::mat4 proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><pre>当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致在游戏中的视觉效果：太过靠近一个物体的时候你的视线会直接穿过去。</pre><p>由于正交投影没有使用透视，远处的物体不会显得更小，所以正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中更希望顶点不会被透视所干扰。</p><ol><li>屏幕空间</li></ol><p>顶点着色器的输出要求所有的顶点都在裁剪空间内，因此先将顶点从局部空间转换到裁剪空间：</p><p>$V_{clip}=M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}$</p><p>转换到裁剪空间后，最后会将结果赋值给顶点着色器的gl_Position，OpenGL将会自动进行透视除法和裁剪操作。</p><p>OpenGL接着会对裁剪坐标执行透视除法将它们变换到标准化设备坐标。OpenGL使用glViewPort内部的参数将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点，这个过程称为视口变换。</p><p><br></p><p>物体变换过程：</p><ul><li><img src="坐标_3.jpg" alt="图2.3"></li></ul><ol><li>局部坐标是对象相对于局部原点的坐标，是物体起始的坐标</li><li>将局部坐标变换为世界空间坐标，这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放</li><li>将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的</li><li>坐标到达观察空间之后，需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上</li><li>最后将裁剪坐标变换为屏幕坐标，这是视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</li></ol><p><br></p><h1 id="3-实现3D效果"><a href="#3-实现3D效果" class="headerlink" title="3. 实现3D效果"></a>3. 实现3D效果</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模型矩阵</span></span><br><span class="line"><span class="comment">// 绕x轴旋转-55度</span></span><br><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建观察矩阵</span></span><br><span class="line"><span class="comment">// 往z轴正方向平移3个单位</span></span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建透视投影矩阵</span></span><br><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将矩阵传递到顶点着色器中</span></span><br><span class="line"><span class="type">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> viewLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;view&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(viewLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> projectionLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(projectionLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projection));</span><br></pre></td></tr></table></figure><p>顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将顶点变换到裁剪空间中，矩阵乘法要从右向左</span></span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="坐标_4.jpg" alt="图3.1"></li></ul><p><br></p><ol><li>3D立方体</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 36个顶点数据，包含顶点坐标和纹理</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改模型矩阵，让立方体随时间旋转</span></span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启深度缓冲</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次渲染迭代之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="坐标_5.gif" alt="图4.1"></li></ul><p><br></p><h1 id="5-更多立方体"><a href="#5-更多立方体" class="headerlink" title="5. 更多立方体"></a>5. 更多立方体</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个立方体的位置</span></span><br><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 赋予不同的模型矩阵</span></span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">    model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><img src="坐标_6.jpg" alt="图4.1"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;对物体的不同操作有不同的意义，你如：当需要对物体进行修改的时候，在局部空间中操作会比较合理；如果要对一个物体做出一个相对</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>变换</title>
    <link href="https://raoyuqi.github.io/2023/07/25/graphic/opengl/%E5%8F%98%E6%8D%A2/"/>
    <id>https://raoyuqi.github.io/2023/07/25/graphic/opengl/%E5%8F%98%E6%8D%A2/</id>
    <published>2023-07-25T13:32:02.000Z</published>
    <updated>2023-07-26T13:52:25.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-向量"><a href="#1-向量" class="headerlink" title="1. 向量"></a>1. 向量</h1><p>既有大小又有方向的量，称为向量。向量相等的依据：方向相同且大小相等，如下图起点不同的两个向量 $\vec{v}$ 和 $\vec{w}$ 是相等的：</p><ul><li><img src="变换_1.jpg" alt="图1.1"></li></ul><p>向量数学表示：$\vec{v}=\begin{pmatrix} x \\ y \\ z \end{pmatrix}$</p><p><br></p><h1 id="2-向量运算"><a href="#2-向量运算" class="headerlink" title="2. 向量运算"></a>2. 向量运算</h1><h2 id="2-1-向量与标量"><a href="#2-1-向量与标量" class="headerlink" title="2.1 向量与标量"></a>2.1 向量与标量</h2><p>$\begin{pmatrix} x \\ y \\ z \end{pmatrix} + 1 = \begin{pmatrix} x+1 \\ y+1 \\ z+1 \end{pmatrix}$</p><h2 id="2-2-向量取反"><a href="#2-2-向量取反" class="headerlink" title="2.2 向量取反"></a>2.2 向量取反</h2><p>$-\vec{v}=-\begin{pmatrix} x \\ y \\ z \end{pmatrix}=\begin{pmatrix} -x \\ -y \\ -z \end{pmatrix}$</p><h2 id="2-3-向量加减"><a href="#2-3-向量加减" class="headerlink" title="2.3 向量加减"></a>2.3 向量加减</h2><p>$\vec{v}+\vec{w}=\begin{pmatrix} 1 \\ 2 \\ 3 \end{pmatrix}+\begin{pmatrix} 4 \\ 5 \\ 6 \end{pmatrix}=\begin{pmatrix} 5 \\ 7 \\ 9 \end{pmatrix}$</p><ul><li><img src="变换_2.jpg" alt="图2.3.1"></li></ul><p>$\vec{v}-\vec{w}=\begin{pmatrix} 1 \\ 2 \\ 3 \end{pmatrix}-\begin{pmatrix} 4 \\ 5 \\ 6 \end{pmatrix}=\begin{pmatrix} -3 \\ -3 \\ -3 \end{pmatrix}$</p><ul><li><img src="变换_3.jpg" alt="图2.3.2"></li></ul><h2 id="2-4-向量长度和单位向量"><a href="#2-4-向量长度和单位向量" class="headerlink" title="2.4 向量长度和单位向量"></a>2.4 向量长度和单位向量</h2><p>向量长度：$||\vec{v}||=\sqrt{x^2+y^2}$</p><p>单位向量：$\widehat{n} = \frac{\vec{v}}{||\vec{v}||}$</p><ul><li><img src="变换_4.jpg" alt="图2.3.3"></li></ul><h2 id="2-4-向量相乘"><a href="#2-4-向量相乘" class="headerlink" title="2.4 向量相乘"></a>2.4 向量相乘</h2><ol><li>点乘</li></ol><p>$\vec{v} \cdot \vec{w} = ||\vec{v}|| \cdot ||\vec{w}|| \cdot \cos\vartheta$</p><p>两个单位向量的点乘结果为两个向量的夹角：$\vec{v} \cdot \vec{w} = 1 \cdot 1 \cdot \cos\vartheta = \cos\vartheta$</p><p>几何意义：判断两个向量方向的相似性，即两个向量是否垂直、平行、方向相反等。</p><p>点乘计算：$\begin{pmatrix} 1 \\ -1 \\ 0 \end{pmatrix} \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} = (0.6 * 0) + (-1 * 1) + (0 * 0) = -1$，反余弦可得两向量夹角180度，方向相反。</p><ol><li>叉乘</li></ol><p>叉乘会生成一个垂直于两个向量的新向量，叉乘可以用来判断两个向量的位置关系，即一个向量是在另一个向量的右边还是左边。</p><p>叉乘计算：$\begin{pmatrix} A_x \\ A_y \\ A_z \end{pmatrix} \cdot \begin{pmatrix} B_x \\ B_y \\ B_z \end{pmatrix} = \begin{pmatrix} A_y \cdot B_z-A_z \cdot B_y \\ A_z \cdot B_x-A_x \cdot B_z \\ A_x \cdot B_y-A_y \cdot B_x \end{pmatrix}$</p><p><br></p><h1 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h1><p>矩阵就是一个矩形的数字、符号或表达式数组，矩阵中每一项叫做矩阵的元素。</p><h2 id="3-1-矩阵相乘"><a href="#3-1-矩阵相乘" class="headerlink" title="3.1 矩阵相乘"></a>3.1 矩阵相乘</h2><p>条件：</p><ol><li>左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘</li><li>矩阵相乘不遵守交换律，$A \cdot B \not= B \cdot A$</li></ol><p>例：</p><p>$\left[\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \end{matrix}\right] \cdot \left[\begin{matrix} 5 &amp; 6 \\ 7 &amp; 8 \\ \end{matrix}\right]=\left[\begin{matrix} 1 \cdot 5+2 \cdot 7 &amp; 1 \cdot 6+2 \cdot 8 \\ 3 \cdot 5+4 \cdot 7 &amp; 3 \cdot 6+4 \cdot 8 \\ \end{matrix}\right]=\left[\begin{matrix} 19 &amp; 22 \\ 43 &amp; 50 \\ \end{matrix}\right]$</p><h2 id="3-2-矩阵乘以向量"><a href="#3-2-矩阵乘以向量" class="headerlink" title="3.2 矩阵乘以向量"></a>3.2 矩阵乘以向量</h2><p>矩阵可以用来变换向量：</p><ol><li>缩放</li></ol><p>$\left[\begin{matrix} S_1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; S_2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; S_3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right] \cdot \left(\begin{matrix} x \\ y \\ z \\ w \\ \end{matrix}\right)=\left(\begin{matrix} S_1 \cdot x \\ S_2 \cdot y \\ S_3 \cdot z \\ w \\ \end{matrix}\right)$</p><ul><li><img src="变换_5.jpg" alt="图3.2.1"></li></ul><ol><li>平移</li></ol><p>$\left[\begin{matrix} 1 &amp; 0 &amp; 0 &amp; T_x \\ 0 &amp; 1 &amp; 0 &amp; T_y \\ 0 &amp; 0 &amp; 1 &amp; T_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right] \cdot \left(\begin{matrix} x \\ y \\ z \\ 1 \\ \end{matrix}\right)=\left(\begin{matrix} x+T_x \\ y+T_y \\ z+T_z \\ 1 \\ \end{matrix}\right)$</p><pre>向量的w分量也叫齐次坐标，可以把x、y和z坐标分别除以w坐标从而将其次坐标转换为3D向量。如果w分类为1，则表示的是坐标，如果w分量为0，则表示的是向量。其次坐标的一个主要用途是将平移操作由仿射变换转换为线性变换。</pre><ol><li>旋转</li></ol><p>绕x轴：$\left[\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \cos\vartheta &amp; -\sin\vartheta &amp; 0 \\ 0 &amp; \sin\vartheta &amp; \cos\vartheta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p><p>绕y轴：$\left[\begin{matrix} \cos\vartheta &amp; 0 &amp; \sin\vartheta &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -\sin\vartheta &amp; 0 &amp; \cos\vartheta &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p><p>绕z轴：$\left[\begin{matrix} \cos\vartheta &amp; -\sin\vartheta &amp; 0 &amp; 0 \\ \sin\vartheta &amp; \cos\vartheta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{matrix}\right]$</p><h2 id="3-3-矩阵组合"><a href="#3-3-矩阵组合" class="headerlink" title="3.3 矩阵组合"></a>3.3 矩阵组合</h2><p>将多个矩阵相乘可以将多个变换组合到一个矩阵中，比如先缩放再平移：$M=Trans \cdot Scale -&gt; Trans \cdot Scale \cdot \vec{v}=M \cdot \vec{v}$，矩阵相乘时，最右边的矩阵会先和向量相乘，所以这边表示的操作是先缩放后平移。</p><p><br></p><h1 id="4-GLM"><a href="#4-GLM" class="headerlink" title="4. GLM"></a>4. GLM</h1><p>GLM是OpenGL Mathematics的缩写，这是一个OpenGL数学库，点击<a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">链接</a>进行下载，然后把头文件的根目录复制到includes文件夹就可以使用了，这里用的是低于0.99版本的GLM。</p><p>使用GLM库进行平移操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个向量</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 创建一个平移矩阵，平移(1, 1, 0)个单位</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="comment">// 平移操作</span></span><br><span class="line">vec = trans * vec;</span><br></pre></td></tr></table></figure><p>将变换应用到图形中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个矩阵</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line"><span class="comment">// 绕z轴逆时针旋转90度，glm::radians将角度转化为弧度</span></span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line"><span class="comment">// 缩放0.5倍</span></span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把矩阵传递给顶点着色器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(shader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="comment">// GLM的默认布局就是列主序，所以并不需要转置矩阵</span></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br></pre></td></tr></table></figure><p>顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵</span></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 变换操作</span></span><br><span class="line">    gl_Position = transform * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><ul><li><img src="变换_6.jpg" alt="图4.1"></li></ul><p>让矩形随着时间进行旋转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>矩阵的乘法是从右往左的，因此这里会先绕(0, 0, 1)旋转，然后再平移到屏幕右下角，虽然在逻辑上是先平移后旋转。</p><p>运行程序：</p><ul><li><img src="变换_7.gif" alt="图4.2"><br><br></li></ul><h1 id="5-扩展阅读"><a href="#5-扩展阅读" class="headerlink" title="5. 扩展阅读"></a>5. 扩展阅读</h1><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">线性代数本质</a>：<a href="https://space.bilibili.com/88461692#!/channel/detail?cid=9450">中文字幕版本</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-向量&quot;&gt;&lt;a href=&quot;#1-向量&quot; class=&quot;headerlink&quot; title=&quot;1. 向量&quot;&gt;&lt;/a&gt;1. 向量&lt;/h1&gt;&lt;p&gt;既有大小又有方向的量，称为向量。向量相等的依据：方向相同且大小相等，如下图起点不同的两个向量 $&#92;vec{v}$ 和 $</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>纹理</title>
    <link href="https://raoyuqi.github.io/2023/07/21/graphic/opengl/%E7%BA%B9%E7%90%86/"/>
    <id>https://raoyuqi.github.io/2023/07/21/graphic/opengl/%E7%BA%B9%E7%90%86/</id>
    <published>2023-07-21T12:56:56.000Z</published>
    <updated>2023-07-21T13:20:03.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-纹理的作用"><a href="#1-纹理的作用" class="headerlink" title="1. 纹理的作用"></a>1. 纹理的作用</h1><p>通过给顶点输入颜色数据可以让顶点显示指定的颜色，如果想渲染出更真实的图形，那么就需要足够多的顶点数据和颜色数据才能实现，这样开销很大。使用纹理可以解决这个问题。</p><p>纹理通常是一张2D图片（也有1D和3D的），是存储物体细节的容器，可以将物体需要的细节数据存储在纹理中，渲染的时候从纹理中采样出所需要的数据，这样就可以让物体非常的同时也不用添加大量的顶点数据。相当于把纹理贴到物体表面，这样物体就有了该纹理的外观，如下图：</p><ul><li><img src="%E7%BA%B9%E7%90%86_1.jpg" alt="图1.1"></li></ul><p>想要把纹理映射到三角形上，需要指定每个三角形的每个顶点对应纹理的哪个部分，让每个顶点和纹理坐标关联起来，表示每个顶点该从纹理的哪个部分采样。纹理坐标的范围在0到1之间，使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，终始于(1, 1)，下图展示了怎样将纹理映射到三角形：</p><ul><li><img src="%E7%BA%B9%E7%90%86_2.jpg" alt="图1.2"></li></ul><p>纹理映射只要给顶点着色器传递纹理坐标就行，它们会被传片段着色器中，片段着色器中会为每个片段进行纹理坐标的插值。</p><br><h1 id="2-环绕方式"><a href="#2-环绕方式" class="headerlink" title="2. 环绕方式"></a>2. 环绕方式</h1><p>纹理坐标范围从(0, 0)到(1, 1)，假设把纹理坐标设置在这个范围之外，应该如何表现？OpenGL提供了以下表现形式：</p><ul><li>GL_REPEAT: 重复纹理图像</li><li>GL_MIRRORED_REPEAT: 镜像重复</li><li>GL_CLAMP_TO_EDGE: 超出的部分会重复纹理坐标的边缘，产生边缘被拉伸的效果</li><li>GL_CLAMP_TO_BORDER: 超出的坐标为自定义的边缘颜色</li></ul><p>视觉效果如下图：</p><ul><li><img src="%E7%BA%B9%E7%90%86_3.jpg" alt="图2.1"></li></ul><p>设置代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置s(x)轴超出镜像重复</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">// 设置t(y)轴超出镜像重复</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">// 指定颜色</span></span><br><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><br><h1 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3. 过滤"></a>3. 过滤</h1><p>纹理是由纹理像素组成，而采样的时候使用的是纹理坐标，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标。有了映射方法才能够根据纹理坐标去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色，最终显示。这里会有一些问题：</p><ol><li>纹理分辨率很小：图像上的多个像素在渲染时取纹理映射上取到了同一个点，会有明显的方块状</li><li>纹理分辨率过大：图像上的一个像素覆盖的多个纹素，远处出现摩尔纹，进出出现锯齿</li></ol><p>因此，需要一些过滤方法进行处理，纹理过滤最重要的两种：</p><ol><li>GL_NEAREST</li></ol><p>邻近过滤，OpenGL的默认过滤方式，当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素，如下图：</p><ul><li><img src="%E7%BA%B9%E7%90%86_4.jpg" alt="图3.1"></li></ul><ol start="2"><li>GL_LINEAR</li></ol><p>线性过滤，选取纹理坐标附近的n个纹理像素使用插值方法，进行颜色混合。一个纹理像素的中心距离纹理坐标越近对最终的样本颜色的贡献越大，如下图：</p><ul><li><img src="%E7%BA%B9%E7%90%86_5.jpg" alt="图3.2"></li></ul><p>两种方式的效果：</p><ul><li><img src="%E7%BA%B9%E7%90%86_6.jpg" alt="图3.3"></li></ul><p>线性过滤更够生成更加平滑的效果，通常在图片被放大后可以设置为线性过滤，而初始状态或者别缩小可以设置为邻近过滤节省性能，设置代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><br><h1 id="4-Mipmap"><a href="#4-Mipmap" class="headerlink" title="4. Mipmap"></a>4. Mipmap</h1><p>在透视投影下，远处的物体会更小，如果这时候让它们使用和近处分辨率一样大的纹理，则不合适。由于远处的物体只产生很少的片段，而纹理分辨率太高，导致一个片段会跨越大范围纹理（即像素覆盖一片纹理区域）， 因此OpenGL很难对该片段只拾取一个纹理颜色，导致在小物体上这会产生不真实的感觉；同时高分辨率占用的内存也大，在远处物体上造成内存浪费。</p><p>OpenGL使用多级渐远纹理(Mipmap)解决该问题，Mipmap是一系列的纹理图像，后一个纹理图像是前一个的二分之一。思想：对不同距离的物体，使用不同的多级渐远纹理。同时，多级渐远纹理的性能也很好，Mipmap占用内存只是原始纹理的1.33倍，Mipmap如下：</p><ul><li><img src="%E7%BA%B9%E7%90%86_7.jpg" alt="图4.1"></li></ul><p>OpenGL创建Mipmap：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="comment">// 不要将放大的操作设置为Mipmap的过滤选项，这回产生异常，因为纹理放大不会使用Mipmap</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><br><h1 id="5-纹理的加载与创建"><a href="#5-纹理的加载与创建" class="headerlink" title="5. 纹理的加载与创建"></a>5. 纹理的加载与创建</h1><h2 id="5-1-加载纹理"><a href="#5-1-加载纹理" class="headerlink" title="5.1 加载纹理"></a>5.1 加载纹理</h2><p><a href="https://github.com/nothings">Sean Barrett</a>的一个非常流行的单头文件图像加载库，<a href="https://github.com/nothings/stb/blob/master/stb_image.h">下载链接</a>。加载图片：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽高和颜色通道</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;image.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="5-2-创建纹理"><a href="#5-2-创建纹理" class="headerlink" title="5.2 创建纹理"></a>5.2 创建纹理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1个纹理</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用纹理数据生成纹理</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="comment">// 生成Mipmap</span></span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数据</span></span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure><h2 id="5-3-应用纹理"><a href="#5-3-应用纹理" class="headerlink" title="5.3 应用纹理"></a>5.3 应用纹理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顶点数据中添加纹理坐标用来告诉OpenGL如何对纹理进行采样</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新的顶点格式：</p><ul><li><img src="%E7%BA%B9%E7%90%86_8.jpg" alt="图5.3.1"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析纹理坐标并启用</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采样器</span></span><br><span class="line">uniform sampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用纹理坐标在采样器中采样纹理的颜色</span></span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行程序：</p><ul><li><img src="%E7%BA%B9%E7%90%86_9.jpg" alt="图5.3.2"></li></ul><br><h1 id="6-纹理单元"><a href="#6-纹理单元" class="headerlink" title="6. 纹理单元"></a>6. 纹理单元</h1><p>个纹理的位置值通常称为一个纹理单元，纹理的默认纹理单元是0，它也是默认的激活纹理单元。有了纹理单元就可以在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器可以一次绑定多个纹理，然后激活对应的纹理单元，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在绑定纹理之前先激活纹理单元，纹理单元0默认被激活</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>修改片段着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据第三个参数进行线性插值</span></span><br><span class="line">    <span class="comment">// 如果第三个值是0.0，它会返回第一个输入</span></span><br><span class="line">    <span class="comment">// 如果是1.0，会返回第二个输入值</span></span><br><span class="line">    <span class="comment">// 0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色</span></span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用第二张纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改顶点</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">2.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">2.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">2.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转y轴</span></span><br><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入纹理图片...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定和激活</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置uniform变量之要先前激活着色器程序</span></span><br><span class="line">ourShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">// 设置采样器对应的纹理单元</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture2&quot;</span>), <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行程序：</p><ul><li><img src="%E7%BA%B9%E7%90%86_10.jpg" alt="图6.1"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-纹理的作用&quot;&gt;&lt;a href=&quot;#1-纹理的作用&quot; class=&quot;headerlink&quot; title=&quot;1. 纹理的作用&quot;&gt;&lt;/a&gt;1. 纹理的作用&lt;/h1&gt;&lt;p&gt;通过给顶点输入颜色数据可以让顶点显示指定的颜色，如果想渲染出更真实的图形，那么就需要足够多的顶点</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>着色器</title>
    <link href="https://raoyuqi.github.io/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    <id>https://raoyuqi.github.io/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/</id>
    <published>2023-07-18T13:20:44.000Z</published>
    <updated>2023-07-21T13:20:44.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-程序结构"><a href="#1-程序结构" class="headerlink" title="1. 程序结构"></a>1. 程序结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="2-输入与输出"><a href="#2-输入与输出" class="headerlink" title="2. 输入与输出"></a>2. 输入与输出</h1><p>着色器虽然都是独立的小程序，但是最后经过编译链接后都是一个整体的一部分，所以每个着色器都通过输入和输出进行数据交互。GLSL定义了in和out关键字专门来实现这个目的，遵循原则：<strong>输出变量与下一个着色器阶段的输入匹配（类型与变量名完全一致），就会传递下去。</strong></p><p>顶点着色器可以使用location指定输入变量，实现可以在CPU上配置顶点属性，从顶点数据中直接接收输入，如layout (location &#x3D; 0) in vec3 pos。</p><pre>也可以忽略layout (location = 0)标识符，使用glGetAttribLocation查询属性位置值(Location)，在着色器中设置可以节省OpenGL的工作量。</pre><br><ol><li>顶点着色器</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>片段着色器</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器需要输出最终像素颜色，如果没有定义输出颜色会显示黑或白，这里颜色通过顶点着色器发送。vertexColor在两个着色器中类型和变量名完全一致，因此在编译链接着色器程序的过程中，OpenGL会把两个变量链接在一起，使它们可以发送数据。</p><p>运行程序：</p><ul><li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_1.jpg" alt="图2.1"></li></ul><br><h1 id="3-Uniform"><a href="#3-Uniform" class="headerlink" title="3. Uniform"></a>3. Uniform</h1><p>特点：</p><ul><li>支持从CPU发送数据到GPU</li><li>变量是全局的，它可以被着色器程序的任意着色器在任意阶段访问</li><li>论你把uniform值设置成什么，uniform会一直保存它们的数据，直到被重置或更新</li><li>声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，最后编译出的版本中并不会包含它</li></ul><p>修改片段着色器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CPU中传递颜色数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染</span></span><br><span class="line">    <span class="comment">// 清除颜色缓冲</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得激活着色器</span></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运行时间</span></span><br><span class="line">    <span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">    <span class="comment">// 颜色分量</span></span><br><span class="line">    <span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    <span class="comment">// 查询uniform ourColor的位置值，返回-1代表没有找到这个位置值</span></span><br><span class="line">    <span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">    <span class="comment">// 激活着色器程序</span></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 设置颜色值，更新uniform值之前必须先激活着色器程序</span></span><br><span class="line">    <span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制三角形</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲并查询IO事件</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><ul><li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_2.gif" alt="图3.1"></li></ul><br><h1 id="4-链接更多属性"><a href="#4-链接更多属性" class="headerlink" title="4. 链接更多属性"></a>4. 链接更多属性</h1><p>把颜色添加到顶点数据中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调整顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line">out vec3 ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除片段着色器中的uniform变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;  </span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了另一个顶点属性，并且更新了VBO的内存后，VBO内存中的数据布局：</p><ul><li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_3.jpg" alt="图4.1"></li></ul><p>解析顶点数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性，位置0</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性，位置1，起始偏移3 * sizeof(float)</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>运行程序：</p><ul><li><img src="%E7%9D%80%E8%89%B2%E5%99%A8_4.jpg" alt="图4.2"></li></ul><br><h1 id="5-着色器类"><a href="#5-着色器类" class="headerlink" title="5. 着色器类"></a>5. 着色器类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="comment">// constructor generates the shader on the fly</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> <span class="type">char</span>* vertexPath, <span class="type">const</span> <span class="type">char</span>* fragmentPath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. retrieve the vertex/fragment source code from filePath</span></span><br><span class="line">        std::string vertexCode;</span><br><span class="line">        std::string fragmentCode;</span><br><span class="line">        std::ifstream vShaderFile;</span><br><span class="line">        std::ifstream fShaderFile;</span><br><span class="line">        <span class="comment">// ensure ifstream objects can throw exceptions:</span></span><br><span class="line">        vShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        fShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// open files</span></span><br><span class="line">            vShaderFile.<span class="built_in">open</span>(vertexPath);</span><br><span class="line">            fShaderFile.<span class="built_in">open</span>(fragmentPath);</span><br><span class="line">            std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">            <span class="comment">// read file&#x27;s buffer contents into streams</span></span><br><span class="line">            vShaderStream &lt;&lt; vShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            fShaderStream &lt;&lt; fShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            <span class="comment">// close file handlers</span></span><br><span class="line">            vShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            fShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            <span class="comment">// convert stream into string</span></span><br><span class="line">            vertexCode   = vShaderStream.<span class="built_in">str</span>();</span><br><span class="line">            fragmentCode = fShaderStream.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::ifstream::failure&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 2. compile shaders</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vertex, fragment;</span><br><span class="line">        <span class="comment">// vertex shader</span></span><br><span class="line">        vertex = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(vertex);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line">        <span class="comment">// fragment Shader</span></span><br><span class="line">        fragment = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(fragment, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(fragment);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line">        <span class="comment">// shader Program</span></span><br><span class="line">        ID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, vertex);</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, fragment);</span><br><span class="line">        <span class="built_in">glLinkProgram</span>(ID);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br><span class="line">        <span class="comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span></span><br><span class="line">        <span class="built_in">glDeleteShader</span>(vertex);</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// activate the shader</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUseProgram</span>(ID); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// utility uniform functions</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">bool</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;         </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), (<span class="type">int</span>)value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">float</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// utility function for checking shader compilation/linking errors.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkCompileErrors</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shader, std::string type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> success;</span><br><span class="line">        <span class="type">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="string">&quot;PROGRAM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetShaderInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetProgramInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;path/to/shaders/shader.vs&quot;</span>, <span class="string">&quot;path/to/shaders/shader.fs&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;someUniform&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-程序结构&quot;&gt;&lt;a href=&quot;#1-程序结构&quot; class=&quot;headerlink&quot; title=&quot;1. 程序结构&quot;&gt;&lt;/a&gt;1. 程序结构&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>画三角形</title>
    <link href="https://raoyuqi.github.io/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>https://raoyuqi.github.io/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</id>
    <published>2023-07-17T12:46:20.000Z</published>
    <updated>2023-07-21T13:20:50.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图形渲染管线"><a href="#1-图形渲染管线" class="headerlink" title="1. 图形渲染管线"></a>1. 图形渲染管线</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>图形渲染管线是个流水线，分为好几个阶段，主要的工作为：将3D空间中的坐标转换为屏幕空间的2D坐标，并最终把2D坐标转换为有颜色的像素，形成画面。</p><br><h2 id="1-2-着色器"><a href="#1-2-着色器" class="headerlink" title="1.2 着色器"></a>1.2 着色器</h2><p>图形渲染管线分为多个阶段，每个阶段会把前一个阶段的输出作为输入。每个阶段高度专门化，非常容易并行执行，因此大多数显卡都有成千上万个小处理核心，处理核心负责在GPU上为每个流水线阶段处运行各自的程序，达到在渲染管线中快速并行地处理数据，这些小程序就是着色器。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写的。</p><br><h2 id="1-3-阶段"><a href="#1-3-阶段" class="headerlink" title="1.3 阶段"></a>1.3 阶段</h2><p>如图，蓝色部分是可以自定义的部分：</p><ul><li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_1.jpg" alt="图形渲染管线"></li></ul><ol><li>顶点着色器</li></ol><p>以顶点坐标作为输入，将其处理成齐次坐标。</p><ol start="2"><li>图元装配</li></ol><p>将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定的图元形状（点、三角形等）。</p><ol start="3"><li>几何着色器</li></ol><p>把图元装配形成的顶点集合作为输入，这个阶段可以产生新顶点，构造出新的图元来生成其它形状。</p><ol start="4"><li>光栅化阶段</li></ol><p>几何着色器的输出作为输入，这个阶段会把图元映射为最终屏幕上对应的像素，生成给片段着色器使用的片段。生成片段过程中会执行裁剪，丢弃超出视图以外的所有像素，提升下个阶段的效率。</p><ol start="5"><li>片段着色器</li></ol><p>这里会计算出像素最后显示的颜色，是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色</p><ol start="6"><li>Alpha测试和混合</li></ol><p>这是最后一个阶段，会对片段进行一系列检测，如深度和模板测试，透明度测试及混合等。</p><p><strong>现代OpenGL中，至少定义一个顶点着色器和片段着色器。</strong></p><br><h1 id="2-绘制三角形"><a href="#2-绘制三角形" class="headerlink" title="2. 绘制三角形"></a>2. 绘制三角形</h1><ol><li>准备顶点数据</li></ol><p>tip: OpenGL是3D图形库，因此指定的坐标需要是3D坐标；OpenGL只处理标准化设备坐标，即-1.0到1.0范围内的坐标，并不是简单地把3D坐标转换为屏幕上的2D像素。</p><p>给定如下输入坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个z坐标设为0，让它看上去是2D的</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre>深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果被别的像素遮挡，就看不到它了，将会被丢弃，以节省资源。</pre><p>该组坐标在标准化设备中对应如下三角形：</p><ul><li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_2.jpg" alt="标准化设备中的三角形"></li></ul><p>接下来把顶点坐标传给渲染管线的第一个阶段（顶点着色器），顶点着色器会在GPU上创建内存，用来存储顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。</p><ol start="2"><li>创建VBO</li></ol><p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被成为显存）中存储大量顶点。使用缓冲对象的好处是可以批量发送数据到显卡上，而不是每次发送一个顶点。从CPU把数据发送到显卡相对较慢，但是当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建VBO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到GL_ARRAY_BUFFER，绑定后使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><pre>希望显卡如何管理给定的数据的三种形式：- GL_STATIC_DRAW ：数据不会或几乎不会改变- GL_DYNAMIC_DRAW：数据会被改变很多- GL_STREAM_DRAW ：数据每次绘制时都会改变</pre><p>这样顶点数据就被存储到显存中了，被VBO这个顶点缓冲对象所管理着。</p><br><ol start="3"><li>着色器</li></ol><p>用GLSL编写顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号和核心模式</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="comment">// 设定了输入变量的位置值</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 接收顶点数据</span></span><br><span class="line">in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ol start="4"><li>编译着色器</li></ol><p>将第3步的着色器代码赋值给字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个顶点着色器对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器源码附加到着色器对象上</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><br><ol start="5"><li>着色器程序</li></ol><p>着色器程序对象是多个着色器最终链接完成的版本。如果要使用刚才编译的着色器必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在发送渲染调用的时候被使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建着色器程序对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="comment">// 附加着色器对象到程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="comment">// 链接</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活着色器程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// 释放不再需要的资源</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><p>到这一步已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理这些数据。接下来需要告诉OpenGL如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。</p><br><ol start="6"><li>链接顶点属性</li></ol><p>必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以必须在渲染前指定OpenGL该如何解释顶点数据，顶点缓冲数据会被解析为下面这样子：</p><ul><li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_3.jpg" alt="顶点缓冲数据"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 以顶点属性位置值作为参数，启用顶点属性，默认是禁用的</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br><ol start="7"><li>顶点数组对象VAO</li></ol><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。好处是，当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了，因为设置的所有状态都将存储在VAO中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个VAO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>当打算绘制多个物体时，首先要生成&#x2F;配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。这段代码应该看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 绘制物体</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br><span class="line"><span class="comment">// 解绑VAO</span></span><br></pre></td></tr></table></figure><br><ol start="8"><li>绘制三角形</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活着色器程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 画三角形，顶点数组的起始索引为0，绘制3个顶点</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果：</p><ul><li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_4.jpg" alt="三角形"></li></ul><br><h1 id="3-元素缓冲对象"><a href="#3-元素缓冲对象" class="headerlink" title="3. 元素缓冲对象"></a>3. 元素缓冲对象</h1><p>元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。假设不绘制一个三角形而是绘制一个矩形。可以绘制两个三角形来组成一个矩形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个矩形只有4个而不是6个顶点，这样会产生50%的额外开销，如果有包括上千个三角形的模型，这会产生一大堆浪费。可以通过<strong>只储存不同的顶点，并设定绘制这些顶点的顺序。</strong>这样子只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行。元素缓冲区对象就是用来做这个的。</p><p>EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储OpenGL用来决定要绘制哪些顶点的顺序。定义不重复的顶点和绘制出矩形所需的索引顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意索引从0开始! </span></span><br><span class="line"><span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line"><span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EBO对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="comment">// 把索引复制到缓冲里</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引缓冲区渲染三角形</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>结果：</p><ul><li><img src="%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2_5.jpg" alt="矩形"></li></ul><pre>线框模式glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示打算将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到调用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-图形渲染管线&quot;&gt;&lt;a href=&quot;#1-图形渲染管线&quot; class=&quot;headerlink&quot; title=&quot;1. 图形渲染管线&quot;&gt;&lt;/a&gt;1. 图形渲染管线&lt;/h1&gt;&lt;h2 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>创建窗口</title>
    <link href="https://raoyuqi.github.io/2023/07/15/graphic/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/"/>
    <id>https://raoyuqi.github.io/2023/07/15/graphic/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/</id>
    <published>2023-07-15T01:01:48.000Z</published>
    <updated>2023-07-21T13:20:55.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-实例化GLFW窗口"><a href="#1-实例化GLFW窗口" class="headerlink" title="1. 实例化GLFW窗口"></a>1. 实例化GLFW窗口</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="comment">//设置OpenGL主版本号(Major)和次版本号(Minor)</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//告诉GLFW使用的是核心模式(Core-profile)</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">//Mac OS X系统的额外设置</span></span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="2-创建窗口"><a href="#2-创建窗口" class="headerlink" title="2. 创建窗口"></a>2. 创建窗口</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Hello Word&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知GLFW将窗口的上下文设置为当前线程的主上下文了</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="3-初始化GLAD"><a href="#3-初始化GLAD" class="headerlink" title="3. 初始化GLAD"></a>3. 初始化GLAD</h1><p>GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//GLAD是用来管理OpenGL的函数指针的</span></span><br><span class="line">    <span class="comment">//调用任何OpenGL的函数之前先需要初始化GLAD</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW的glfwGetProcAddress根据编译的系统定义了正确的函数。</li></ul><br><h1 id="4-设置视口"><a href="#4-设置视口" class="headerlink" title="4. 设置视口"></a>4. 设置视口</h1><p>必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。并且注册窗口大小改变的回调监听。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="comment">//告诉GLFW每当窗口调整大小的时候调用framebuffer_size_callback函数更新视口</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="5-渲染循环"><a href="#5-渲染循环" class="headerlink" title="5. 渲染循环"></a>5. 渲染循环</h1><p>添加渲染循环，在GLFW退出前一直保持运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="comment">//函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre>双缓冲(Double Buffer)应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</pre><br><h1 id="6-输入"><a href="#6-输入" class="headerlink" title="6. 输入"></a>6. 输入</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="comment">//函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-资源释放"><a href="#7-资源释放" class="headerlink" title="7. 资源释放"></a>7. 资源释放</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//渲染循环结束后需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-实例化GLFW窗口&quot;&gt;&lt;a href=&quot;#1-实例化GLFW窗口&quot; class=&quot;headerlink&quot; title=&quot;1. 实例化GLFW窗口&quot;&gt;&lt;/a&gt;1. 实例化GLFW窗口&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL环境部署</title>
    <link href="https://raoyuqi.github.io/2023/07/13/graphic/opengl/OpenGL%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://raoyuqi.github.io/2023/07/13/graphic/opengl/OpenGL%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</id>
    <published>2023-07-13T13:35:40.000Z</published>
    <updated>2023-07-21T13:21:00.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。基于该规范编程在不同操作系统会有差异，借助库可以节省编写操作系统相关的代码，流行的库有：GLUT，SDL，SFML和GLFW。</p><br><h1 id="2-部署环境"><a href="#2-部署环境" class="headerlink" title="2. 部署环境"></a>2. 部署环境</h1><h2 id="2-1-GLFW"><a href="#2-1-GLFW" class="headerlink" title="2.1 GLFW"></a>2.1 GLFW</h2><p>一个专门针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口。允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入等。</p><p>从官网<a href="https://www.glfw.org/download.html">下载</a>并将其解压，接着创建一个build目录作为最终导出目录，然后使用CMake工具生成工程文件。</p><p>下载<a href="https://cmake.org/download/">CMake</a>并安装，执行cmake-gui，如下设置：</p><ul><li><img src="opengl%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_1.jpg" alt="CMake"></li></ul><p>点击Generate按钮，生成的工程文件会在build文件夹中。</p><p>在build文件夹里可以找到GLFW.sln文件，用Visual Studio 2019打开。因为CMake已经配置好了项目，并按照默认配置将其编译为64位的库，所以直接点击Build Solution(生成解决方案)，然后在build&#x2F;src&#x2F;Debug文件夹内就会出现我们编译出的库文件glfw3.lib。</p><br><h2 id="2-2-GLFW链接"><a href="#2-2-GLFW链接" class="headerlink" title="2.2 GLFW链接"></a>2.2 GLFW链接</h2><p>建立一个新的目录用来存放所有的第三方库文件和头文件，建议包含Libs和Include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。</p><p>打开Visual Studio，创建一个新的项目。选择Visual C++，然后选择空项目，接着将项目从x86更改为x64。为了使程序能够使用GLFW，需要把GLFW库链接进工程：</p><ul><li><img src="opengl%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_2.jpg" alt="链接1"></li><li><img src="opengl%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_3.jpg" alt="链接2"></li></ul><ul><li>在Windows平台，opengl32.lib已经包含在Microsoft SDK里了，它在Visual Studio安装的时候就默认安装了。只需将opengl32.lib添加进连接器设置里就行了。OpenGL库64位版本的文件名仍然是opengl32.lib（和32位版本一样）。</li></ul><br><h2 id="2-3-GLAD"><a href="#2-3-GLAD" class="headerlink" title="2.3 GLAD"></a>2.3 GLAD</h2><p>由于OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上类似这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GL_GENBUFFERS)</span> <span class="params">(GLsizei, GLuint*)</span></span>;</span><br><span class="line"><span class="comment">// 找到正确的函数并赋值给函数指针</span></span><br><span class="line">GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)<span class="built_in">wglGetProcAddress</span>(<span class="string">&quot;glGenBuffers&quot;</span>);</span><br><span class="line"><span class="comment">// 现在函数可以被正常调用了</span></span><br><span class="line">GLuint buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></table></figure><p>使用GLAD库可以简化这个过程。</p><p>打开GLAD的<a href="https://glad.dav1d.de/">在线服务</a>，如下设置：</p><ul><li><img src="opengl%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_4.jpg" alt="设置"></li></ul><p>点击Generate按钮来生成库文件，下载GLAD生成的压缩包并解压，将两个头文件目录（glad和KHR）复制到Include文件夹中，并添加glad.c文件到工程中，到此环境配置就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。基于该规范编程在不同操作系统会有差异</summary>
      
    
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://raoyuqi.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://raoyuqi.github.io/2023/07/11/hello-world/"/>
    <id>https://raoyuqi.github.io/2023/07/11/hello-world/</id>
    <published>2023-07-11T13:30:41.175Z</published>
    <updated>2023-07-11T13:30:41.175Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
