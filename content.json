{"meta":{"title":"奇遇的博客","subtitle":"","description":"","author":"John Doe","url":"https://raoyuqi.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2023-07-19T12:40:46.000Z","updated":"2023-07-19T13:37:47.381Z","comments":true,"path":"categories/index.html","permalink":"https://raoyuqi.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"坐标","slug":"graphic/opengl/坐标","date":"2023-07-26T13:53:31.000Z","updated":"2023-07-26T14:20:18.946Z","comments":false,"path":"2023/07/26/graphic/opengl/坐标/","link":"","permalink":"https://raoyuqi.github.io/2023/07/26/graphic/opengl/%E5%9D%90%E6%A0%87/","excerpt":"","text":"1. 概述对物体的不同操作有不同的意义，你如：当需要对物体进行修改的时候，在局部空间中操作会比较合理；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中更合理，等等。因此也衍生出了不同的坐标空间。 2. 坐标空间 局部空间 物体所在的坐标空间，即对象最开始所在的地方。建模软件中创建了一个立方体，立方体的原点有可能位于(0, 0, 0)，有可能创建的所有模型都以(0, 0, 0)为初始位置，然而它们会最终出现在世界的不同位置。所以，模型的所有顶点都是在局部空间中：它们相对于物体来说都是局部的。 世界空间 指顶点相对于游戏世界的坐标。如果希望将物体分散在世界上摆放，就需要将物体变换到世界空间。该变换是由模型矩阵(Model Matrix)实现的。模型矩阵能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。经过模型矩阵变换后，物体的坐标将会从局部变换到世界空间。 观察空间 以摄像机为视角观察到的空间，因此也称摄像机空间。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果，因此观察空间就是从摄像机的视角所观察到的空间。改变换由观察矩阵(View Matrix)实现。 裁剪空间 OpenGL希望所有的坐标都在一个特定的范围内，所有不在范围内的顶点都会被裁剪丢弃，剩下才会进行处理，节省不必要的消耗。将顶点从观察空间变换到裁剪空间需要使用投影矩阵。指定了一个坐标范围，如：-100到100，投影矩阵会将该指定范围转换为标准化设备的范围(-1.0, 1.0)。所有在(-1.0, 1.0)之外的顶点都会被裁剪，比如顶点坐标为(80, 101)会被裁剪，因为转换后y坐标超出了范围，应该丢弃。 如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让它能够适合这个裁剪范围。 由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程被称之为投影(Projection)。 当所有顶点被变换到裁剪空间，会执行透视除法，在这个过程中做的就是将位置向量的x，y，z分量分别除以向量的齐次w分量；目的是把4D裁剪空间的齐次坐标变换为3D标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。 在这一阶段之后，最终的坐标将会被映射到屏幕空间中（即glViewport中的设定），并被变换成片段。投影矩阵有两种： 正交投影 正交投影定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。 由于每个向量的w分量都没有进行改变（w分量等于1.0），因此透视除法后坐标不变，出现的视觉效果是，进出的物体和远处的物体大小一致，造成不真实感。 GLM创建正交投影矩阵： 1234// 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部// 通过这四个参数定义近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离// 这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f); 透视投影 现实生活中近大远小的现象称为透视，要实现透视效果需要使用透视投影矩阵来完成。透视投影矩阵将给定的平截头体范围映射到裁剪空间，还会修改每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何不在这个范围的坐标都会被裁剪掉）。OpenGL对在范围内的顶点进行透视除法操作： $out=\\begin{pmatrix} x/w \\\\ y/w \\\\ z/w \\end{pmatrix}$ 由于越远的物体w分量越大，因此模拟除了透视效果，这是w重要用途之一。 GLM创建透视投影矩阵： 1234// 第一个参数定义了fov的值，表示的是视野(Field of View)，想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值// 第二个参数设置了宽高比，由视口的宽除以高所得// 第三和第四个参数设置了平截头体的近和远平面。通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); 当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致在游戏中的视觉效果：太过靠近一个物体的时候你的视线会直接穿过去。 由于正交投影没有使用透视，远处的物体不会显得更小，所以正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中更希望顶点不会被透视所干扰。 屏幕空间 顶点着色器的输出要求所有的顶点都在裁剪空间内，因此先将顶点从局部空间转换到裁剪空间： $V_{clip}=M_{projection} \\cdot M_{view} \\cdot M_{model} \\cdot V_{local}$ 转换到裁剪空间后，最后会将结果赋值给顶点着色器的gl_Position，OpenGL将会自动进行透视除法和裁剪操作。 OpenGL接着会对裁剪坐标执行透视除法将它们变换到标准化设备坐标。OpenGL使用glViewPort内部的参数将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点，这个过程称为视口变换。 物体变换过程： 局部坐标是对象相对于局部原点的坐标，是物体起始的坐标 将局部坐标变换为世界空间坐标，这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放 将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的 坐标到达观察空间之后，需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上 最后将裁剪坐标变换为屏幕坐标，这是视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段 3. 实现3D效果1234567891011121314151617181920212223// 创建模型矩阵// 绕x轴旋转-55度glm::mat4 model;model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));// 创建观察矩阵// 往z轴正方向平移3个单位glm::mat4 view;view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));// 创建透视投影矩阵glm::mat4 projection;projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);// 将矩阵传递到顶点着色器中int modelLoc = glGetUniformLocation(shader.ID, &quot;model&quot;));glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));int viewLoc = glGetUniformLocation(shader.ID, &quot;view&quot;));glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));int projectionLoc = glGetUniformLocation(shader.ID, &quot;model&quot;));glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection)); 顶点着色器： 12345678910111213#version 330 corelayout (location = 0) in vec3 aPos;...uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; // 将顶点变换到裁剪空间中，矩阵乘法要从右向左 gl_Position = projection * view * model * vec4(aPos, 1.0); ...&#125; 效果： 3D立方体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 36个顶点数据，包含顶点坐标和纹理float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f&#125;;// 修改模型矩阵，让立方体随时间旋转model = glm::rotate(model, (float)glfwGetTime() * glm::radians(20.0f), glm::vec3(0.5f, 1.0f, 0.0f));// 开启深度缓冲glEnable(GL_DEPTH_TEST);// 在每次渲染迭代之前清除深度缓冲，否则前一帧的深度信息仍然保存在缓冲中glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);// 绘制glDrawArrays(GL_TRIANGLES, 0, 36); 效果： 5. 更多立方体12345678910111213141516171819202122232425262728// 每个立方体的位置glm::vec3 cubePositions[] = &#123; glm::vec3( 0.0f, 0.0f, 0.0f), glm::vec3( 2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3( 2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3( 1.3f, -2.0f, -2.5f), glm::vec3( 1.5f, 2.0f, -2.5f), glm::vec3( 1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;;...glBindVertexArray(VAO);for(unsigned int i = 0; i &lt; 10; i++)&#123; // 赋予不同的模型矩阵 glm::mat4 model; model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 36);&#125; 效果：","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"变换","slug":"graphic/opengl/变换","date":"2023-07-25T13:32:02.000Z","updated":"2023-07-26T13:52:25.161Z","comments":false,"path":"2023/07/25/graphic/opengl/变换/","link":"","permalink":"https://raoyuqi.github.io/2023/07/25/graphic/opengl/%E5%8F%98%E6%8D%A2/","excerpt":"","text":"1. 向量既有大小又有方向的量，称为向量。向量相等的依据：方向相同且大小相等，如下图起点不同的两个向量 $\\vec{v}$ 和 $\\vec{w}$ 是相等的： 向量数学表示：$\\vec{v}=\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$ 2. 向量运算2.1 向量与标量$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} + 1 = \\begin{pmatrix} x+1 \\\\ y+1 \\\\ z+1 \\end{pmatrix}$ 2.2 向量取反$-\\vec{v}=-\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}=\\begin{pmatrix} -x \\\\ -y \\\\ -z \\end{pmatrix}$ 2.3 向量加减$\\vec{v}+\\vec{w}=\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}+\\begin{pmatrix} 4 \\\\ 5 \\\\ 6 \\end{pmatrix}=\\begin{pmatrix} 5 \\\\ 7 \\\\ 9 \\end{pmatrix}$ $\\vec{v}-\\vec{w}=\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}-\\begin{pmatrix} 4 \\\\ 5 \\\\ 6 \\end{pmatrix}=\\begin{pmatrix} -3 \\\\ -3 \\\\ -3 \\end{pmatrix}$ 2.4 向量长度和单位向量向量长度：$||\\vec{v}||=\\sqrt{x^2+y^2}$ 单位向量：$\\widehat{n} = \\frac{\\vec{v}}{||\\vec{v}||}$ 2.4 向量相乘 点乘 $\\vec{v} \\cdot \\vec{w} = ||\\vec{v}|| \\cdot ||\\vec{w}|| \\cdot \\cos\\vartheta$ 两个单位向量的点乘结果为两个向量的夹角：$\\vec{v} \\cdot \\vec{w} = 1 \\cdot 1 \\cdot \\cos\\vartheta = \\cos\\vartheta$ 几何意义：判断两个向量方向的相似性，即两个向量是否垂直、平行、方向相反等。 点乘计算：$\\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = (0.6 * 0) + (-1 * 1) + (0 * 0) = -1$，反余弦可得两向量夹角180度，方向相反。 叉乘 叉乘会生成一个垂直于两个向量的新向量，叉乘可以用来判断两个向量的位置关系，即一个向量是在另一个向量的右边还是左边。 叉乘计算：$\\begin{pmatrix} A_x \\\\ A_y \\\\ A_z \\end{pmatrix} \\cdot \\begin{pmatrix} B_x \\\\ B_y \\\\ B_z \\end{pmatrix} = \\begin{pmatrix} A_y \\cdot B_z-A_z \\cdot B_y \\\\ A_z \\cdot B_x-A_x \\cdot B_z \\\\ A_x \\cdot B_y-A_y \\cdot B_x \\end{pmatrix}$ 3. 矩阵矩阵就是一个矩形的数字、符号或表达式数组，矩阵中每一项叫做矩阵的元素。 3.1 矩阵相乘条件： 左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘 矩阵相乘不遵守交换律，$A \\cdot B \\not= B \\cdot A$ 例： $\\left[\\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix}\\right] \\cdot \\left[\\begin{matrix} 5 &amp; 6 \\\\ 7 &amp; 8 \\\\ \\end{matrix}\\right]=\\left[\\begin{matrix} 1 \\cdot 5+2 \\cdot 7 &amp; 1 \\cdot 6+2 \\cdot 8 \\\\ 3 \\cdot 5+4 \\cdot 7 &amp; 3 \\cdot 6+4 \\cdot 8 \\\\ \\end{matrix}\\right]=\\left[\\begin{matrix} 19 &amp; 22 \\\\ 43 &amp; 50 \\\\ \\end{matrix}\\right]$ 3.2 矩阵乘以向量矩阵可以用来变换向量： 缩放 $\\left[\\begin{matrix} S_1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; S_3 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right] \\cdot \\left(\\begin{matrix} x \\\\ y \\\\ z \\\\ w \\\\ \\end{matrix}\\right)=\\left(\\begin{matrix} S_1 \\cdot x \\\\ S_2 \\cdot y \\\\ S_3 \\cdot z \\\\ w \\\\ \\end{matrix}\\right)$ 平移 $\\left[\\begin{matrix} 1 &amp; 0 &amp; 0 &amp; T_x \\\\ 0 &amp; 1 &amp; 0 &amp; T_y \\\\ 0 &amp; 0 &amp; 1 &amp; T_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right] \\cdot \\left(\\begin{matrix} x \\\\ y \\\\ z \\\\ 1 \\\\ \\end{matrix}\\right)=\\left(\\begin{matrix} x+T_x \\\\ y+T_y \\\\ z+T_z \\\\ 1 \\\\ \\end{matrix}\\right)$ 向量的w分量也叫齐次坐标，可以把x、y和z坐标分别除以w坐标从而将其次坐标转换为3D向量。如果w分类为1，则表示的是坐标，如果w分量为0，则表示的是向量。 其次坐标的一个主要用途是将平移操作由仿射变换转换为线性变换。 旋转 绕x轴：$\\left[\\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\vartheta &amp; -\\sin\\vartheta &amp; 0 \\\\ 0 &amp; \\sin\\vartheta &amp; \\cos\\vartheta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right]$ 绕y轴：$\\left[\\begin{matrix} \\cos\\vartheta &amp; 0 &amp; \\sin\\vartheta &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin\\vartheta &amp; 0 &amp; \\cos\\vartheta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right]$ 绕z轴：$\\left[\\begin{matrix} \\cos\\vartheta &amp; -\\sin\\vartheta &amp; 0 &amp; 0 \\\\ \\sin\\vartheta &amp; \\cos\\vartheta &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right]$ 3.3 矩阵组合将多个矩阵相乘可以将多个变换组合到一个矩阵中，比如先缩放再平移：$M=Trans \\cdot Scale -&gt; Trans \\cdot Scale \\cdot \\vec{v}=M \\cdot \\vec{v}$，矩阵相乘时，最右边的矩阵会先和向量相乘，所以这边表示的操作是先缩放后平移。 4. GLMGLM是OpenGL Mathematics的缩写，这是一个OpenGL数学库，点击链接进行下载，然后把头文件的根目录复制到includes文件夹就可以使用了，这里用的是低于0.99版本的GLM。 使用GLM库进行平移操作： 1234567891011#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;// 创建一个向量glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);// 创建一个平移矩阵，平移(1, 1, 0)个单位glm::mat4 trans;trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));// 平移操作vec = trans * vec; 将变换应用到图形中： 1234567891011// 创建一个矩阵glm::mat4 trans;// 绕z轴逆时针旋转90度，glm::radians将角度转化为弧度trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));// 缩放0.5倍trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));// 把矩阵传递给顶点着色器unsigned int transformLoc = glGetUniformLocation(shader.ID, &quot;transform&quot;);// GLM的默认布局就是列主序，所以并不需要转置矩阵glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans)); 顶点着色器： 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoord;out vec2 TexCoord;// 矩阵uniform mat4 transform;void main()&#123; // 变换操作 gl_Position = transform * vec4(aPos, 1.0f); TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);&#125; 运行程序： 让矩形随着时间进行旋转： 123glm::mat4 trans;trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f)); 矩阵的乘法是从右往左的，因此这里会先绕(0, 0, 1)旋转，然后再平移到屏幕右下角，虽然在逻辑上是先平移后旋转。 运行程序： 5. 扩展阅读线性代数本质：中文字幕版本","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"纹理","slug":"graphic/opengl/纹理","date":"2023-07-21T12:56:56.000Z","updated":"2023-07-21T13:20:03.668Z","comments":false,"path":"2023/07/21/graphic/opengl/纹理/","link":"","permalink":"https://raoyuqi.github.io/2023/07/21/graphic/opengl/%E7%BA%B9%E7%90%86/","excerpt":"","text":"1. 纹理的作用通过给顶点输入颜色数据可以让顶点显示指定的颜色，如果想渲染出更真实的图形，那么就需要足够多的顶点数据和颜色数据才能实现，这样开销很大。使用纹理可以解决这个问题。 纹理通常是一张2D图片（也有1D和3D的），是存储物体细节的容器，可以将物体需要的细节数据存储在纹理中，渲染的时候从纹理中采样出所需要的数据，这样就可以让物体非常的同时也不用添加大量的顶点数据。相当于把纹理贴到物体表面，这样物体就有了该纹理的外观，如下图： 想要把纹理映射到三角形上，需要指定每个三角形的每个顶点对应纹理的哪个部分，让每个顶点和纹理坐标关联起来，表示每个顶点该从纹理的哪个部分采样。纹理坐标的范围在0到1之间，使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，终始于(1, 1)，下图展示了怎样将纹理映射到三角形： 纹理映射只要给顶点着色器传递纹理坐标就行，它们会被传片段着色器中，片段着色器中会为每个片段进行纹理坐标的插值。 2. 环绕方式纹理坐标范围从(0, 0)到(1, 1)，假设把纹理坐标设置在这个范围之外，应该如何表现？OpenGL提供了以下表现形式： GL_REPEAT: 重复纹理图像 GL_MIRRORED_REPEAT: 镜像重复 GL_CLAMP_TO_EDGE: 超出的部分会重复纹理坐标的边缘，产生边缘被拉伸的效果 GL_CLAMP_TO_BORDER: 超出的坐标为自定义的边缘颜色 视觉效果如下图： 设置代码： 1234567// 设置s(x)轴超出镜像重复glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);// 设置t(y)轴超出镜像重复glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);// 指定颜色float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 3. 过滤纹理是由纹理像素组成，而采样的时候使用的是纹理坐标，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标。有了映射方法才能够根据纹理坐标去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色，最终显示。这里会有一些问题： 纹理分辨率很小：图像上的多个像素在渲染时取纹理映射上取到了同一个点，会有明显的方块状 纹理分辨率过大：图像上的一个像素覆盖的多个纹素，远处出现摩尔纹，进出出现锯齿 因此，需要一些过滤方法进行处理，纹理过滤最重要的两种： GL_NEAREST 邻近过滤，OpenGL的默认过滤方式，当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素，如下图： GL_LINEAR 线性过滤，选取纹理坐标附近的n个纹理像素使用插值方法，进行颜色混合。一个纹理像素的中心距离纹理坐标越近对最终的样本颜色的贡献越大，如下图： 两种方式的效果： 线性过滤更够生成更加平滑的效果，通常在图片被放大后可以设置为线性过滤，而初始状态或者别缩小可以设置为邻近过滤节省性能，设置代码： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 4. Mipmap在透视投影下，远处的物体会更小，如果这时候让它们使用和近处分辨率一样大的纹理，则不合适。由于远处的物体只产生很少的片段，而纹理分辨率太高，导致一个片段会跨越大范围纹理（即像素覆盖一片纹理区域）， 因此OpenGL很难对该片段只拾取一个纹理颜色，导致在小物体上这会产生不真实的感觉；同时高分辨率占用的内存也大，在远处物体上造成内存浪费。 OpenGL使用多级渐远纹理(Mipmap)解决该问题，Mipmap是一系列的纹理图像，后一个纹理图像是前一个的二分之一。思想：对不同距离的物体，使用不同的多级渐远纹理。同时，多级渐远纹理的性能也很好，Mipmap占用内存只是原始纹理的1.33倍，Mipmap如下： OpenGL创建Mipmap： 123glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);// 不要将放大的操作设置为Mipmap的过滤选项，这回产生异常，因为纹理放大不会使用MipmapglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 5. 纹理的加载与创建5.1 加载纹理Sean Barrett的一个非常流行的单头文件图像加载库，下载链接。加载图片： 123456#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;// 宽高和颜色通道int width, height, nrChannels;unsigned char *data = stbi_load(&quot;image.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); 5.2 创建纹理1234567891011121314151617181920// 创建1个纹理unsigned int texture;glGenTextures(1, &amp;texture);// 绑定glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 使用纹理数据生成纹理glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);// 生成MipmapglGenerateMipmap(GL_TEXTURE_2D);// 释放数据stbi_image_free(data); 5.3 应用纹理12345678// 在顶点数据中添加纹理坐标用来告诉OpenGL如何对纹理进行采样float vertices[] = &#123;// ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // 左上&#125;; 新的顶点格式： 123// 解析纹理坐标并启用glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2); 顶点着色器： 1234567891011121314#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main()&#123; gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexCoord;&#125; 片段着色器： 1234567891011121314#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;// 采样器uniform sampler2D ourTexture;void main()&#123; // 使用纹理坐标在采样器中采样纹理的颜色 FragColor = texture(ourTexture, TexCoord);&#125; 绘制： 123glBindTexture(GL_TEXTURE_2D, texture);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 运行程序： 6. 纹理单元个纹理的位置值通常称为一个纹理单元，纹理的默认纹理单元是0，它也是默认的激活纹理单元。有了纹理单元就可以在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器可以一次绑定多个纹理，然后激活对应的纹理单元，如下： 123// 在绑定纹理之前先激活纹理单元，纹理单元0默认被激活glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture); 修改片段着色器： 123456789101112131415#version 330 core...uniform sampler2D texture1;// 新增uniform sampler2D texture2;void main()&#123; // 根据第三个参数进行线性插值 // 如果第三个值是0.0，它会返回第一个输入 // 如果是1.0，会返回第二个输入值 // 0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色 FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);&#125; 使用第二张纹理： 12345678910111213141516171819202122232425262728// 修改顶点float vertices[] = &#123; // ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 2.0f, 2.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 2.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 2.0f // 左上&#125;;// 翻转y轴stbi_set_flip_vertically_on_load(true);// 载入纹理图片...// 绑定和激活glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);// 设置uniform变量之要先前激活着色器程序ourShader.use();// 设置采样器对应的纹理单元glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0);glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture2&quot;), 1); glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 运行程序：","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"着色器","slug":"graphic/opengl/着色器","date":"2023-07-18T13:20:44.000Z","updated":"2023-07-21T13:20:44.233Z","comments":false,"path":"2023/07/18/graphic/opengl/着色器/","link":"","permalink":"https://raoyuqi.github.io/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/","excerpt":"","text":"1. 程序结构123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123; // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;&#125; 2. 输入与输出着色器虽然都是独立的小程序，但是最后经过编译链接后都是一个整体的一部分，所以每个着色器都通过输入和输出进行数据交互。GLSL定义了in和out关键字专门来实现这个目的，遵循原则：输出变量与下一个着色器阶段的输入匹配（类型与变量名完全一致），就会传递下去。 顶点着色器可以使用location指定输入变量，实现可以在CPU上配置顶点属性，从顶点数据中直接接收输入，如layout (location &#x3D; 0) in vec3 pos。 也可以忽略layout (location = 0)标识符，使用glGetAttribLocation查询属性位置值(Location)，在着色器中设置可以节省OpenGL的工作量。 顶点着色器 12345678910#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main()&#123; gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色&#125; 片段着色器 123456789#version 330 coreout vec4 FragColor;in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123; FragColor = vertexColor;&#125; 片段着色器需要输出最终像素颜色，如果没有定义输出颜色会显示黑或白，这里颜色通过顶点着色器发送。vertexColor在两个着色器中类型和变量名完全一致，因此在编译链接着色器程序的过程中，OpenGL会把两个变量链接在一起，使它们可以发送数据。 运行程序： 3. Uniform特点： 支持从CPU发送数据到GPU 变量是全局的，它可以被着色器程序的任意着色器在任意阶段访问 论你把uniform值设置成什么，uniform会一直保存它们的数据，直到被重置或更新 声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，最后编译出的版本中并不会包含它 修改片段着色器代码： 123456789#version 330 coreout vec4 FragColor;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main()&#123; FragColor = ourColor;&#125; 在CPU中传递颜色数据： 1234567891011121314151617181920212223242526272829303132while(!glfwWindowShouldClose(window))&#123; // 输入 processInput(window); // 渲染 // 清除颜色缓冲 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // 记得激活着色器 glUseProgram(shaderProgram); // 获取运行时间 float timeValue = glfwGetTime(); // 颜色分量 float greenValue = (sin(timeValue) / 2.0f) + 0.5f; // 查询uniform ourColor的位置值，返回-1代表没有找到这个位置值 int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); // 激活着色器程序 glUseProgram(shaderProgram); // 设置颜色值，更新uniform值之前必须先激活着色器程序 glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // 绘制三角形 glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); // 交换缓冲并查询IO事件 glfwSwapBuffers(window); glfwPollEvents();&#125; 运行程序： 4. 链接更多属性把颜色添加到顶点数据中： 123456float vertices[] = &#123; // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部&#125;; 调整顶点着色器： 1234567891011#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0 layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1out vec3 ourColor; // 向片段着色器输出一个颜色void main()&#123; gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125; 删除片段着色器中的uniform变量： 12345678#version 330 coreout vec4 FragColor; in vec3 ourColor;void main()&#123; FragColor = vec4(ourColor, 1.0);&#125; 添加了另一个顶点属性，并且更新了VBO的内存后，VBO内存中的数据布局： 解析顶点数据： 123456// 位置属性，位置0glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 颜色属性，位置1，起始偏移3 * sizeof(float)glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1); 运行程序： 5. 着色器类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#ifndef SHADER_H#define SHADER_H#include &lt;glad/glad.h&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader&#123;public: unsigned int ID; // constructor generates the shader on the fly // ------------------------------------------------------------------------ Shader(const char* vertexPath, const char* fragmentPath) &#123; // 1. retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // ensure ifstream objects can throw exceptions: vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); try &#123; // open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // read file&#x27;s buffer contents into streams vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // close file handlers vShaderFile.close(); fShaderFile.close(); // convert stream into string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); &#125; catch (std::ifstream::failure&amp; e) &#123; std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; const char* vShaderCode = vertexCode.c_str(); const char * fShaderCode = fragmentCode.c_str(); // 2. compile shaders unsigned int vertex, fragment; // vertex shader vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); checkCompileErrors(vertex, &quot;VERTEX&quot;); // fragment Shader fragment = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragment, 1, &amp;fShaderCode, NULL); glCompileShader(fragment); checkCompileErrors(fragment, &quot;FRAGMENT&quot;); // shader Program ID = glCreateProgram(); glAttachShader(ID, vertex); glAttachShader(ID, fragment); glLinkProgram(ID); checkCompileErrors(ID, &quot;PROGRAM&quot;); // delete the shaders as they&#x27;re linked into our program now and no longer necessary glDeleteShader(vertex); glDeleteShader(fragment); &#125; // activate the shader // ------------------------------------------------------------------------ void use() &#123; glUseProgram(ID); &#125; // utility uniform functions // ------------------------------------------------------------------------ void setBool(const std::string &amp;name, bool value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); &#125; // ------------------------------------------------------------------------ void setInt(const std::string &amp;name, int value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), value); &#125; // ------------------------------------------------------------------------ void setFloat(const std::string &amp;name, float value) const &#123; glUniform1f(glGetUniformLocation(ID, name.c_str()), value); &#125;private: // utility function for checking shader compilation/linking errors. // ------------------------------------------------------------------------ void checkCompileErrors(unsigned int shader, std::string type) &#123; int success; char infoLog[1024]; if (type != &quot;PROGRAM&quot;) &#123; glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl; &#125; &#125; else &#123; glGetProgramiv(shader, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl; &#125; &#125; &#125;&#125;;#endif 使用： 12345678Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.fs&quot;);...while(...)&#123; ourShader.use(); ourShader.setFloat(&quot;someUniform&quot;, 1.0f); ...&#125;","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"画三角形","slug":"graphic/opengl/画三角形","date":"2023-07-17T12:46:20.000Z","updated":"2023-07-21T13:20:50.162Z","comments":false,"path":"2023/07/17/graphic/opengl/画三角形/","link":"","permalink":"https://raoyuqi.github.io/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"","text":"1. 图形渲染管线1.1 概念图形渲染管线是个流水线，分为好几个阶段，主要的工作为：将3D空间中的坐标转换为屏幕空间的2D坐标，并最终把2D坐标转换为有颜色的像素，形成画面。 1.2 着色器图形渲染管线分为多个阶段，每个阶段会把前一个阶段的输出作为输入。每个阶段高度专门化，非常容易并行执行，因此大多数显卡都有成千上万个小处理核心，处理核心负责在GPU上为每个流水线阶段处运行各自的程序，达到在渲染管线中快速并行地处理数据，这些小程序就是着色器。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写的。 1.3 阶段如图，蓝色部分是可以自定义的部分： 顶点着色器 以顶点坐标作为输入，将其处理成齐次坐标。 图元装配 将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定的图元形状（点、三角形等）。 几何着色器 把图元装配形成的顶点集合作为输入，这个阶段可以产生新顶点，构造出新的图元来生成其它形状。 光栅化阶段 几何着色器的输出作为输入，这个阶段会把图元映射为最终屏幕上对应的像素，生成给片段着色器使用的片段。生成片段过程中会执行裁剪，丢弃超出视图以外的所有像素，提升下个阶段的效率。 片段着色器 这里会计算出像素最后显示的颜色，是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色 Alpha测试和混合 这是最后一个阶段，会对片段进行一系列检测，如深度和模板测试，透明度测试及混合等。 现代OpenGL中，至少定义一个顶点着色器和片段着色器。 2. 绘制三角形 准备顶点数据 tip: OpenGL是3D图形库，因此指定的坐标需要是3D坐标；OpenGL只处理标准化设备坐标，即-1.0到1.0范围内的坐标，并不是简单地把3D坐标转换为屏幕上的2D像素。 给定如下输入坐标： 123456// 将每个z坐标设为0，让它看上去是2D的float vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f&#125;; 深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果被别的像素遮挡， 就看不到它了，将会被丢弃，以节省资源。 该组坐标在标准化设备中对应如下三角形： 接下来把顶点坐标传给渲染管线的第一个阶段（顶点着色器），顶点着色器会在GPU上创建内存，用来存储顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。 创建VBO 通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被成为显存）中存储大量顶点。使用缓冲对象的好处是可以批量发送数据到显卡上，而不是每次发送一个顶点。从CPU把数据发送到显卡相对较慢，但是当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点。 123456789// 创建VBO对象unsigned int VBO;glGenBuffers(1, &amp;VBO);// 绑定到GL_ARRAY_BUFFER，绑定后使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)glBindBuffer(GL_ARRAY_BUFFER, VBO);// 把顶点数据复制到缓冲的内存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 希望显卡如何管理给定的数据的三种形式： - GL_STATIC_DRAW ：数据不会或几乎不会改变 - GL_DYNAMIC_DRAW：数据会被改变很多 - GL_STREAM_DRAW ：数据每次绘制时都会改变 这样顶点数据就被存储到显存中了，被VBO这个顶点缓冲对象所管理着。 着色器 用GLSL编写顶点着色器： 1234567891011// 版本号和核心模式#version 330 core// 设定了输入变量的位置值layout (location = 0)// 接收顶点数据in vec3 aPos;void main()&#123; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125; 编译着色器 将第3步的着色器代码赋值给字符串： 1234567891011121314151617181920212223242526272829// 顶点着色器代码const char *vertexShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) in vec3 aPos;\\n&quot; &quot;void main()\\n&quot; &quot;&#123;\\n&quot; &quot; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot; &quot;&#125;\\0&quot;;// 创建一个顶点着色器对象unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);// 着色器源码附加到着色器对象上glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);// 编译glCompileShader(vertexShader);// 片段着色器代码const char *fragmentShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) out vec4 FragColor;\\n&quot; &quot;void main()\\n&quot; &quot;&#123;\\n&quot; &quot; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot; &quot;&#125;\\0&quot;;unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader); 着色器程序 着色器程序对象是多个着色器最终链接完成的版本。如果要使用刚才编译的着色器必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在发送渲染调用的时候被使用。 1234567891011121314// 创建着色器程序对象unsigned int shaderProgram;shaderProgram = glCreateProgram();// 附加着色器对象到程序glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);// 链接glLinkProgram(shaderProgram);// 激活着色器程序glUseProgram(shaderProgram);// 释放不再需要的资源glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 到这一步已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理这些数据。接下来需要告诉OpenGL如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。 链接顶点属性 必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以必须在渲染前指定OpenGL该如何解释顶点数据，顶点缓冲数据会被解析为下面这样子： 1234// 解析顶点数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);// 以顶点属性位置值作为参数，启用顶点属性，默认是禁用的glEnableVertexAttribArray(0); 顶点数组对象VAO 顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。好处是，当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了，因为设置的所有状态都将存储在VAO中。 123// 创建一个VAO对象unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 当打算绘制多个物体时，首先要生成&#x2F;配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。这段代码应该看起来像这样： 123456789101112131415161718// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..// 1. 绑定VAOglBindVertexArray(VAO);// 2. 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// [...]// ..:: 绘制代码（渲染循环中） :: ..// 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();// 解绑VAO 绘制三角形 123456// 激活着色器程序glUseProgram(shaderProgram);// 绑定VAOglBindVertexArray(VAO);// 画三角形，顶点数组的起始索引为0，绘制3个顶点glDrawArrays(GL_TRIANGLES, 0, 3); 结果： 3. 元素缓冲对象元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。假设不绘制一个三角形而是绘制一个矩形。可以绘制两个三角形来组成一个矩形： 12345678910float vertices[] = &#123; // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;; 一个矩形只有4个而不是6个顶点，这样会产生50%的额外开销，如果有包括上千个三角形的模型，这会产生一大堆浪费。可以通过只储存不同的顶点，并设定绘制这些顶点的顺序。这样子只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行。元素缓冲区对象就是用来做这个的。 EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储OpenGL用来决定要绘制哪些顶点的顺序。定义不重复的顶点和绘制出矩形所需的索引顺序： 123456789101112131415161718192021222324float vertices[] = &#123; 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;;// 注意索引从0开始! // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，// 这样可以由下标代表顶点组合成矩形unsigned int indices[] = &#123; 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形&#125;;// 创建EBO对象unsigned int EBO;glGenBuffers(1, &amp;EBO);// 把索引复制到缓冲里glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 从索引缓冲区渲染三角形glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 结果： 线框模式 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。 第一个参数表示打算将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。 之后的绘制调用会一直以线框模式绘制三角形，直到调用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"创建窗口","slug":"graphic/opengl/创建窗口","date":"2023-07-15T01:01:48.000Z","updated":"2023-07-21T13:20:55.630Z","comments":false,"path":"2023/07/15/graphic/opengl/创建窗口/","link":"","permalink":"https://raoyuqi.github.io/2023/07/15/graphic/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/","excerpt":"","text":"1. 实例化GLFW窗口12345678910111213int main()&#123; glfwInit(); //设置OpenGL主版本号(Major)和次版本号(Minor) glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //告诉GLFW使用的是核心模式(Core-profile) glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //Mac OS X系统的额外设置 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;&#125; 2. 创建窗口1234567891011121314int main()&#123; //创建窗口 GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Hello Word&quot;, NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; //通知GLFW将窗口的上下文设置为当前线程的主上下文了 glfwMakeContextCurrent(window);&#125; 3. 初始化GLADGLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 12345678910int main()&#123; //GLAD是用来管理OpenGL的函数指针的 //调用任何OpenGL的函数之前先需要初始化GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; &#125;&#125; 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW的glfwGetProcAddress根据编译的系统定义了正确的函数。 4. 设置视口必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。并且注册窗口大小改变的回调监听。 12345678910111213void framebuffer_size_callback(GLFWwindow* window, int width, int height);int main()&#123; glViewport(0, 0, 800, 600); //告诉GLFW每当窗口调整大小的时候调用framebuffer_size_callback函数更新视口 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125; 5. 渲染循环添加渲染循环，在GLFW退出前一直保持运行。 1234567int main()&#123; //交换缓冲 glfwSwapBuffers(window); //函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数 glfwPollEvents();&#125; 双缓冲(Double Buffer) 应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。 最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。 为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。 6. 输入12345678910111213141516171819//监听输入void processInput(GLFWwindow* window);void processInput(GLFWwindow* window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;int main()&#123; //输入 processInput(window); //交换缓冲 glfwSwapBuffers(window); //函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数 glfwPollEvents();&#125; 7. 资源释放123456789int main()&#123; //... //渲染循环结束后需要正确释放/删除之前的分配的所有资源 glfwTerminate(); return 0;&#125;","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"OpenGL环境部署","slug":"graphic/opengl/OpenGL环境部署","date":"2023-07-13T13:35:40.000Z","updated":"2023-07-21T13:21:00.893Z","comments":false,"path":"2023/07/13/graphic/opengl/OpenGL环境部署/","link":"","permalink":"https://raoyuqi.github.io/2023/07/13/graphic/opengl/OpenGL%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"","text":"1. 概述OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。基于该规范编程在不同操作系统会有差异，借助库可以节省编写操作系统相关的代码，流行的库有：GLUT，SDL，SFML和GLFW。 2. 部署环境2.1 GLFW一个专门针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口。允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入等。 从官网下载并将其解压，接着创建一个build目录作为最终导出目录，然后使用CMake工具生成工程文件。 下载CMake并安装，执行cmake-gui，如下设置： 点击Generate按钮，生成的工程文件会在build文件夹中。 在build文件夹里可以找到GLFW.sln文件，用Visual Studio 2019打开。因为CMake已经配置好了项目，并按照默认配置将其编译为64位的库，所以直接点击Build Solution(生成解决方案)，然后在build&#x2F;src&#x2F;Debug文件夹内就会出现我们编译出的库文件glfw3.lib。 2.2 GLFW链接建立一个新的目录用来存放所有的第三方库文件和头文件，建议包含Libs和Include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。 打开Visual Studio，创建一个新的项目。选择Visual C++，然后选择空项目，接着将项目从x86更改为x64。为了使程序能够使用GLFW，需要把GLFW库链接进工程： 在Windows平台，opengl32.lib已经包含在Microsoft SDK里了，它在Visual Studio安装的时候就默认安装了。只需将opengl32.lib添加进连接器设置里就行了。OpenGL库64位版本的文件名仍然是opengl32.lib（和32位版本一样）。 2.3 GLAD由于OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上类似这样： 1234567// 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);// 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);// 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); 使用GLAD库可以简化这个过程。 打开GLAD的在线服务，如下设置： 点击Generate按钮来生成库文件，下载GLAD生成的压缩包并解压，将两个头文件目录（glad和KHR）复制到Include文件夹中，并添加glad.c文件到工程中，到此环境配置就完成了。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-07-11T13:30:41.175Z","updated":"2023-07-11T13:30:41.175Z","comments":true,"path":"2023/07/11/hello-world/","link":"","permalink":"https://raoyuqi.github.io/2023/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]}