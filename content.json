{"meta":{"title":"奇遇的博客","subtitle":"","description":"","author":"John Doe","url":"https://raoyuqi.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2023-07-19T12:40:46.000Z","updated":"2023-07-19T13:37:47.381Z","comments":true,"path":"categories/index.html","permalink":"https://raoyuqi.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"着色器","slug":"graphic/opengl/着色器","date":"2023-07-18T13:20:44.000Z","updated":"2023-07-18T13:57:59.661Z","comments":true,"path":"2023/07/18/graphic/opengl/着色器/","link":"","permalink":"https://raoyuqi.github.io/2023/07/18/graphic/opengl/%E7%9D%80%E8%89%B2%E5%99%A8/","excerpt":"","text":"1. 程序结构123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123; // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;&#125; 2. 输入与输出着色器虽然都是独立的小程序，但是最后经过编译链接后都是一个整体的一部分，所以每个着色器都通过输入和输出进行数据交互。GLSL定义了in和out关键字专门来实现这个目的，遵循原则：输出变量与下一个着色器阶段的输入匹配（类型与变量名完全一致），就会传递下去。 顶点着色器可以使用location指定输入变量，实现可以在CPU上配置顶点属性，从顶点数据中直接接收输入，如layout (location &#x3D; 0) in vec3 pos。 也可以忽略layout (location = 0)标识符，使用glGetAttribLocation查询属性位置值(Location)，在着色器中设置可以节省OpenGL的工作量。 顶点着色器 12345678910#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main()&#123; gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色&#125; 片段着色器 123456789#version 330 coreout vec4 FragColor;in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123; FragColor = vertexColor;&#125; 片段着色器需要输出最终像素颜色，如果没有定义输出颜色会显示黑或白，这里颜色通过顶点着色器发送。vertexColor在两个着色器中类型和变量名完全一致，因此在编译链接着色器程序的过程中，OpenGL会把两个变量链接在一起，使它们可以发送数据。 运行程序： 3. Uniform特点： 支持从CPU发送数据到GPU 变量是全局的，它可以被着色器程序的任意着色器在任意阶段访问 论你把uniform值设置成什么，uniform会一直保存它们的数据，直到被重置或更新 声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，最后编译出的版本中并不会包含它 修改片段着色器代码： 123456789#version 330 coreout vec4 FragColor;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main()&#123; FragColor = ourColor;&#125; 在CPU中传递颜色数据： 1234567891011121314151617181920212223242526272829303132while(!glfwWindowShouldClose(window))&#123; // 输入 processInput(window); // 渲染 // 清除颜色缓冲 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // 记得激活着色器 glUseProgram(shaderProgram); // 获取运行时间 float timeValue = glfwGetTime(); // 颜色分量 float greenValue = (sin(timeValue) / 2.0f) + 0.5f; // 查询uniform ourColor的位置值，返回-1代表没有找到这个位置值 int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); // 激活着色器程序 glUseProgram(shaderProgram); // 设置颜色值，更新uniform值之前必须先激活着色器程序 glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // 绘制三角形 glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); // 交换缓冲并查询IO事件 glfwSwapBuffers(window); glfwPollEvents();&#125; 运行程序： 4. 链接更多属性把颜色添加到顶点数据中： 123456float vertices[] = &#123; // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部&#125;; 调整顶点着色器： 1234567891011#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0 layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1out vec3 ourColor; // 向片段着色器输出一个颜色void main()&#123; gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125; 删除片段着色器中的uniform变量： 12345678#version 330 coreout vec4 FragColor; in vec3 ourColor;void main()&#123; FragColor = vec4(ourColor, 1.0);&#125; 添加了另一个顶点属性，并且更新了VBO的内存后，VBO内存中的数据布局： 解析顶点数据： 123456// 位置属性，位置0glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 颜色属性，位置1，起始偏移3 * sizeof(float)glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1); 运行程序： 5. 着色器类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#ifndef SHADER_H#define SHADER_H#include &lt;glad/glad.h&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader&#123;public: unsigned int ID; // constructor generates the shader on the fly // ------------------------------------------------------------------------ Shader(const char* vertexPath, const char* fragmentPath) &#123; // 1. retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // ensure ifstream objects can throw exceptions: vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); try &#123; // open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // read file&#x27;s buffer contents into streams vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // close file handlers vShaderFile.close(); fShaderFile.close(); // convert stream into string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); &#125; catch (std::ifstream::failure&amp; e) &#123; std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; const char* vShaderCode = vertexCode.c_str(); const char * fShaderCode = fragmentCode.c_str(); // 2. compile shaders unsigned int vertex, fragment; // vertex shader vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); checkCompileErrors(vertex, &quot;VERTEX&quot;); // fragment Shader fragment = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragment, 1, &amp;fShaderCode, NULL); glCompileShader(fragment); checkCompileErrors(fragment, &quot;FRAGMENT&quot;); // shader Program ID = glCreateProgram(); glAttachShader(ID, vertex); glAttachShader(ID, fragment); glLinkProgram(ID); checkCompileErrors(ID, &quot;PROGRAM&quot;); // delete the shaders as they&#x27;re linked into our program now and no longer necessary glDeleteShader(vertex); glDeleteShader(fragment); &#125; // activate the shader // ------------------------------------------------------------------------ void use() &#123; glUseProgram(ID); &#125; // utility uniform functions // ------------------------------------------------------------------------ void setBool(const std::string &amp;name, bool value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); &#125; // ------------------------------------------------------------------------ void setInt(const std::string &amp;name, int value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), value); &#125; // ------------------------------------------------------------------------ void setFloat(const std::string &amp;name, float value) const &#123; glUniform1f(glGetUniformLocation(ID, name.c_str()), value); &#125;private: // utility function for checking shader compilation/linking errors. // ------------------------------------------------------------------------ void checkCompileErrors(unsigned int shader, std::string type) &#123; int success; char infoLog[1024]; if (type != &quot;PROGRAM&quot;) &#123; glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl; &#125; &#125; else &#123; glGetProgramiv(shader, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl; &#125; &#125; &#125;&#125;;#endif 使用： 12345678Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.fs&quot;);...while(...)&#123; ourShader.use(); ourShader.setFloat(&quot;someUniform&quot;, 1.0f); ...&#125;","categories":[],"tags":[]},{"title":"画三角形","slug":"graphic/opengl/画三角形","date":"2023-07-17T12:46:20.000Z","updated":"2023-07-17T13:00:46.010Z","comments":true,"path":"2023/07/17/graphic/opengl/画三角形/","link":"","permalink":"https://raoyuqi.github.io/2023/07/17/graphic/opengl/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"","text":"1.1 图形渲染管线1.1.1 概念图形渲染管线是个流水线，分为好几个阶段，主要的工作为：将3D空间中的坐标转换为屏幕空间的2D坐标，并最终把2D坐标转换为有颜色的像素，形成画面。 1.1.2 着色器图形渲染管线分为多个阶段，每个阶段会把前一个阶段的输出作为输入。每个阶段高度专门化，非常容易并行执行，因此大多数显卡都有成千上万个小处理核心，处理核心负责在GPU上为每个流水线阶段处运行各自的程序，达到在渲染管线中快速并行地处理数据，这些小程序就是着色器。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写的。 1.1.3 阶段如图，蓝色部分是可以自定义的部分： 顶点着色器 以顶点坐标作为输入，将其处理成齐次坐标。 图元装配 将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定的图元形状（点、三角形等）。 几何着色器 把图元装配形成的顶点集合作为输入，这个阶段可以产生新顶点，构造出新的图元来生成其它形状。 光栅化阶段 几何着色器的输出作为输入，这个阶段会把图元映射为最终屏幕上对应的像素，生成给片段着色器使用的片段。生成片段过程中会执行裁剪，丢弃超出视图以外的所有像素，提升下个阶段的效率。 片段着色器 这里会计算出像素最后显示的颜色，是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色 Alpha测试和混合 这是最后一个阶段，会对片段进行一系列检测，如深度和模板测试，透明度测试及混合等。 现代OpenGL中，至少定义一个顶点着色器和片段着色器。 2.1 绘制三角形 准备顶点数据 tip: OpenGL是3D图形库，因此指定的坐标需要是3D坐标；OpenGL只处理标准化设备坐标，即-1.0到1.0范围内的坐标，并不是简单地把3D坐标转换为屏幕上的2D像素。 给定如下输入坐标： 123456// 将每个z坐标设为0，让它看上去是2D的float vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f&#125;; 深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果被别的像素遮挡， 就看不到它了，将会被丢弃，以节省资源。 该组坐标在标准化设备中对应如下三角形： 接下来把顶点坐标传给渲染管线的第一个阶段（顶点着色器），顶点着色器会在GPU上创建内存，用来存储顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。 创建VBO 通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被成为显存）中存储大量顶点。使用缓冲对象的好处是可以批量发送数据到显卡上，而不是每次发送一个顶点。从CPU把数据发送到显卡相对较慢，但是当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点。 123456789// 创建VBO对象unsigned int VBO;glGenBuffers(1, &amp;VBO);// 绑定到GL_ARRAY_BUFFER，绑定后使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)glBindBuffer(GL_ARRAY_BUFFER, VBO);// 把顶点数据复制到缓冲的内存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 希望显卡如何管理给定的数据的三种形式： - GL_STATIC_DRAW ：数据不会或几乎不会改变 - GL_DYNAMIC_DRAW：数据会被改变很多 - GL_STREAM_DRAW ：数据每次绘制时都会改变 这样顶点数据就被存储到显存中了，被VBO这个顶点缓冲对象所管理着。 着色器 用GLSL编写顶点着色器： 1234567891011// 版本号和核心模式#version 330 core// 设定了输入变量的位置值layout (location = 0)// 接收顶点数据in vec3 aPos;void main()&#123; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125; 编译着色器 将第3步的着色器代码赋值给字符串： 1234567891011121314151617181920212223242526272829// 顶点着色器代码const char *vertexShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) in vec3 aPos;\\n&quot; &quot;void main()\\n&quot; &quot;&#123;\\n&quot; &quot; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot; &quot;&#125;\\0&quot;;// 创建一个顶点着色器对象unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);// 着色器源码附加到着色器对象上glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);// 编译glCompileShader(vertexShader);// 片段着色器代码const char *fragmentShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) out vec4 FragColor;\\n&quot; &quot;void main()\\n&quot; &quot;&#123;\\n&quot; &quot; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot; &quot;&#125;\\0&quot;;unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader); 着色器程序 着色器程序对象是多个着色器最终链接完成的版本。如果要使用刚才编译的着色器必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在发送渲染调用的时候被使用。 1234567891011121314// 创建着色器程序对象unsigned int shaderProgram;shaderProgram = glCreateProgram();// 附加着色器对象到程序glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);// 链接glLinkProgram(shaderProgram);// 激活着色器程序glUseProgram(shaderProgram);// 释放不再需要的资源glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 到这一步已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理这些数据。接下来需要告诉OpenGL如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。 链接顶点属性 必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以必须在渲染前指定OpenGL该如何解释顶点数据，顶点缓冲数据会被解析为下面这样子： 1234// 解析顶点数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);// 以顶点属性位置值作为参数，启用顶点属性，默认是禁用的glEnableVertexAttribArray(0); 顶点数组对象VAO 顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。好处是，当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了，因为设置的所有状态都将存储在VAO中。 123// 创建一个VAO对象unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 当打算绘制多个物体时，首先要生成&#x2F;配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。这段代码应该看起来像这样： 123456789101112131415161718// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..// 1. 绑定VAOglBindVertexArray(VAO);// 2. 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// [...]// ..:: 绘制代码（渲染循环中） :: ..// 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();// 解绑VAO 绘制三角形 123456// 激活着色器程序glUseProgram(shaderProgram);// 绑定VAOglBindVertexArray(VAO);// 画三角形，顶点数组的起始索引为0，绘制3个顶点glDrawArrays(GL_TRIANGLES, 0, 3); 结果： 3.1 元素缓冲对象元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。假设不绘制一个三角形而是绘制一个矩形。可以绘制两个三角形来组成一个矩形： 12345678910float vertices[] = &#123; // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;; 一个矩形只有4个而不是6个顶点，这样会产生50%的额外开销，如果有包括上千个三角形的模型，这会产生一大堆浪费。可以通过只储存不同的顶点，并设定绘制这些顶点的顺序。这样子只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行。元素缓冲区对象就是用来做这个的。 EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储OpenGL用来决定要绘制哪些顶点的顺序。定义不重复的顶点和绘制出矩形所需的索引顺序： 123456789101112131415161718192021222324float vertices[] = &#123; 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;;// 注意索引从0开始! // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，// 这样可以由下标代表顶点组合成矩形unsigned int indices[] = &#123; 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形&#125;;// 创建EBO对象unsigned int EBO;glGenBuffers(1, &amp;EBO);// 把索引复制到缓冲里glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 从索引缓冲区渲染三角形glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 结果： 线框模式 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。 第一个参数表示打算将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。 之后的绘制调用会一直以线框模式绘制三角形，直到调用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。","categories":[],"tags":[]},{"title":"创建窗口","slug":"graphic/opengl/创建窗口","date":"2023-07-15T01:01:48.000Z","updated":"2023-07-15T01:04:14.827Z","comments":true,"path":"2023/07/15/graphic/opengl/创建窗口/","link":"","permalink":"https://raoyuqi.github.io/2023/07/15/graphic/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/","excerpt":"","text":"1.1 实例化GLFW窗口12345678910111213int main()&#123; glfwInit(); //设置OpenGL主版本号(Major)和次版本号(Minor) glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //告诉GLFW使用的是核心模式(Core-profile) glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //Mac OS X系统的额外设置 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;&#125; 2.1 创建窗口1234567891011121314int main()&#123; //创建窗口 GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Hello Word&quot;, NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; //通知GLFW将窗口的上下文设置为当前线程的主上下文了 glfwMakeContextCurrent(window);&#125; 3.1 初始化GLADGLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 12345678910int main()&#123; //GLAD是用来管理OpenGL的函数指针的 //调用任何OpenGL的函数之前先需要初始化GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; &#125;&#125; 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW的glfwGetProcAddress根据编译的系统定义了正确的函数。 4.1 设置视口必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。并且注册窗口大小改变的回调监听。 12345678910111213void framebuffer_size_callback(GLFWwindow* window, int width, int height);int main()&#123; glViewport(0, 0, 800, 600); //告诉GLFW每当窗口调整大小的时候调用framebuffer_size_callback函数更新视口 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125; 5.1 渲染循环添加渲染循环，在GLFW退出前一直保持运行。 1234567int main()&#123; //交换缓冲 glfwSwapBuffers(window); //函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数 glfwPollEvents();&#125; 双缓冲(Double Buffer) 应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。 最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。 为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。 6.1 输入12345678910111213141516171819//监听输入void processInput(GLFWwindow* window);void processInput(GLFWwindow* window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;int main()&#123; //输入 processInput(window); //交换缓冲 glfwSwapBuffers(window); //函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数 glfwPollEvents();&#125; 7.1 资源释放123456789int main()&#123; //... //渲染循环结束后需要正确释放/删除之前的分配的所有资源 glfwTerminate(); return 0;&#125;","categories":[],"tags":[]},{"title":"OpenGL环境部署","slug":"graphic/opengl/OpenGL环境部署","date":"2023-07-13T13:35:40.000Z","updated":"2023-07-19T13:58:45.785Z","comments":true,"path":"2023/07/13/graphic/opengl/OpenGL环境部署/","link":"","permalink":"https://raoyuqi.github.io/2023/07/13/graphic/opengl/OpenGL%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"","text":"1.1 概述OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。基于该规范编程在不同操作系统会有差异，借助库可以节省编写操作系统相关的代码，流行的库有：GLUT，SDL，SFML和GLFW。 2.1 部署环境2.1.1 GLFW一个专门针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口。允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入等。 从官网下载并将其解压，接着创建一个build目录作为最终导出目录，然后使用CMake工具生成工程文件。 下载CMake并安装，执行cmake-gui，如下设置： 点击Generate按钮，生成的工程文件会在build文件夹中。 在build文件夹里可以找到GLFW.sln文件，用Visual Studio 2019打开。因为CMake已经配置好了项目，并按照默认配置将其编译为64位的库，所以直接点击Build Solution(生成解决方案)，然后在build&#x2F;src&#x2F;Debug文件夹内就会出现我们编译出的库文件glfw3.lib。 2.1.2 GLFW链接建立一个新的目录用来存放所有的第三方库文件和头文件，建议包含Libs和Include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。 打开Visual Studio，创建一个新的项目。选择Visual C++，然后选择空项目，接着将项目从x86更改为x64。为了使程序能够使用GLFW，需要把GLFW库链接进工程： 在Windows平台，opengl32.lib已经包含在Microsoft SDK里了，它在Visual Studio安装的时候就默认安装了。只需将opengl32.lib添加进连接器设置里就行了。OpenGL库64位版本的文件名仍然是opengl32.lib（和32位版本一样）。 2.2.1 GLAD由于OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上类似这样： 1234567// 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);// 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);// 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); 使用GLAD库可以简化这个过程。 打开GLAD的在线服务，如下设置： 点击Generate按钮来生成库文件，下载GLAD生成的压缩包并解压，将两个头文件目录（glad和KHR）复制到Include文件夹中，并添加glad.c文件到工程中，到此环境配置就完成了。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-07-11T13:30:41.175Z","updated":"2023-07-11T13:30:41.175Z","comments":true,"path":"2023/07/11/hello-world/","link":"","permalink":"https://raoyuqi.github.io/2023/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://raoyuqi.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://raoyuqi.github.io/tags/OpenGL/"}]}